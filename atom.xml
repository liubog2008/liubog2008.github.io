<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liubog2008.github.io/"/>
  <updated>2019-04-08T14:29:27.208Z</updated>
  <id>https://liubog2008.github.io/</id>
  
  <author>
    <name>liubog2008</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes 源码分析之 kubelet(一)</title>
    <link href="https://liubog2008.github.io/2019/04/08/kubernetes-one-md/"/>
    <id>https://liubog2008.github.io/2019/04/08/kubernetes-one-md/</id>
    <published>2019-04-08T13:15:22.000Z</published>
    <updated>2019-04-08T14:29:27.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><p>v1.12.4</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>面试被问 pod 的生命周期，说到 kubelet 创建 pod 的部分时只提了 kubelet 发 API 给 docker 创建 container，被认为对 kubernetes 不够熟悉。<br>想了想接触 kubernetes 这么多年了，确实没有真的系统的看过所有代码，认了，查漏补缺吧，挨个写写 kubernetes 的这些个核心组件。<br>之所以用 1.12.4 是因为本地恰好用的 1.12.4，如果 1.14 有想关注的更新会额外写 blog。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>kubelet 是什么就不说了，它的主要代码集中在 kubernetes 项目下的 <code>/pkg/kubelet</code> 位置，总的来说项目结构是相当的清晰。下面是一级目录的简单说明。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- apis/              kubelet 的 api 相关</span><br><span class="line">- cadvisor/          容器指标采集系统，https://github.com/google/cadvisor</span><br><span class="line">- certificate/       证书相关</span><br><span class="line">- checkpoint/        checkpoint 功能 (没看前真不知道这功能)</span><br><span class="line">- checkpointmanager/ checkpoint 管理</span><br><span class="line">- client/            用来访问 kubelet 的 client?</span><br><span class="line">- cloudresource/     用来和云服务交互的部分</span><br><span class="line">- cm/                cgroups manager (cgroups or container?)</span><br><span class="line">- config/            pod config 相关？</span><br><span class="line">- configmap/         configmap 相关</span><br><span class="line">- container/         CRI 相关</span><br><span class="line">- custommetrics/     同文件名</span><br><span class="line">- dockershim/        docker interface</span><br><span class="line">- envvars/           容器里的一些环境变量</span><br><span class="line">- events/            一堆事件的 constant</span><br><span class="line">- eviction/          pod eviction，这个亲切</span><br><span class="line">- images/            容器镜像相关，主要是 pull 和 gc</span><br><span class="line">- kubeletconfig/     kubelet config (凭什么不是上面那个 config 改名)</span><br><span class="line">- kuberuntime/       kubelet runtime 相关</span><br><span class="line">- leaky/             emmm... 就是一些要弄死的代码，而且看起来已经都弄死了</span><br><span class="line">- lifecycle/         pod lifecycle 相关的接口</span><br><span class="line">- logs/              container log 相关，主要是 rotation 之类的逻辑</span><br><span class="line">- metrics/           prometheus metrics</span><br><span class="line">- mountpod/          volume plugin 相关？</span><br><span class="line">- network/           用来配置 pod dns 的</span><br><span class="line">- nodelease/         又是一个不清楚的功能，看起来和租户相关？</span><br><span class="line">- nodestatus/        定义了很多节点状态更新用的 setter</span><br><span class="line">- pleg/              pod lifecycle event generator</span><br><span class="line">- pod/               pod manager</span><br><span class="line">- preemption/        优先级抢占相关</span><br><span class="line">- prober/            pod liveness or readiness probe</span><br><span class="line">- qos/               算 oom 分的</span><br><span class="line">- remote/            貌似实现了 cri 定义的一些 service?</span><br><span class="line">- secret/            挂载 secret 相关</span><br><span class="line">- server/            kubelet 提供的 exec，portforward 等 API的 server</span><br><span class="line">- stats/             CRI stats provider</span><br><span class="line">- status/            pod status manager</span><br><span class="line">- sysctl/            sysctl 相关 (并不知道干什么用)</span><br><span class="line">- token/             service account token 相关</span><br><span class="line">- types/             emmm... 一些 types？</span><br><span class="line">- util/              一些 utils</span><br><span class="line">- volumemanager/     数据卷管理</span><br><span class="line">- winstats/          windows 节点相关</span><br></pre></td></tr></table></figure><p>内容还是很多的，浏览思路是以 pod 的整个生命周期为线索，抓住主线代码，为此罗列以下几个关键问题：</p><ul><li>如何创建 pod</li><li>如何 sync pod 状态</li><li>如何调用 API 创建 container</li><li>pod 的 configmap 和 secret 如何管理</li><li>pod 的 volume 如何管理</li><li>pod 的 network 如何管理</li><li>如何删除 pod</li></ul><p>除此之外按照 feature 的视角来看还有：</p><ul><li>metrics 采集</li><li>remote command 相关的实现</li><li>eviction 功能的实现</li><li>CRI 相关的实现</li><li>其他</li></ul><h2 id="Pod-Lifecycle"><a href="#Pod-Lifecycle" class="headerlink" title="Pod Lifecycle"></a>Pod Lifecycle</h2><p>pod 的整个生命周期往往要从它被 controller 创建开始聊起。然而本文的主要关注点在 kubelet 相关的代码上，因此更关心 pod 被调度到某个节点，也就是当 pod 的 nodeName 字段不为空后会发生什么。</p><h3 id="从-kubelet-go-开始聊起"><a href="#从-kubelet-go-开始聊起" class="headerlink" title="从 kubelet.go 开始聊起"></a>从 kubelet.go 开始聊起</h3><p>从什么地方找出 pod 相关的代码呢？我们可以看到 <code>/pkg/kubelet</code> 文件夹下有一个叫做 <code>kubelet.go</code> 的文件，显然这是 kubelet 主体代码的入口。</p><p>很快我们发现里面有一个叫做 <code>Kubelet</code> 的结构体和一个叫做 <code>NewMainKubelet</code> 以及一个 <code>(kl *Kubelet) Run(updates &lt;-chan kubetypes.PodUpdate)</code> 的函数。</p><p>其中 <code>Kubelet</code> 是 kubelet 的核心结构体，而 <code>NewMainKubelet</code> 是构造函数，<code>Run</code> 则是入口函数。</p><p>看看 <code>Run</code> 这个函数做了什么：</p><ul><li>初始化了 <code>kl.logServer</code></li><li>检查了 <code>kl.kubeClient</code>，之所以这里可能为空是因为 apiserver 可以是 kubelet 拉起来的</li><li>运行 <code>kl.cloudResourceManager</code></li><li>运行 <code>kl.initializeModules</code><ul><li>注册 prometheus metrics</li><li>初始化 kubelet 所需的文件夹</li><li>初始化 container 日志文件夹</li><li>运行管理镜像 GC 的模块 <code>kl.imageManager</code></li><li>运行证书管理模块 <code>kl.serverCertificateManager</code></li><li>运行 OOM 监控模块 <code>kl.oomWatcher</code></li><li>运行资源分析模块 <code>kl.resourceAnalyzer</code></li></ul></li><li>运行 volume 管理组件 <code>kl.volumeManager</code></li><li>如果 apiserver 已经运行了<ul><li>运行 goroutine 定时同步 node 状态</li><li>快速进行一次状态同步</li><li>运行 <code>kl.nodeLeaseController</code></li></ul></li><li>运行 goroutine 同步 container runtime uptime</li><li>运行 goroutine 同步 iptables 规则 (暂未明白这个同步的意义)</li><li>运行 <code>kl.podKiller</code></li><li>运行 pod 状态管理模块 <code>kl.statusManager</code></li><li>运行 pod 探针模块 <code>kl.probeManager</code></li><li>运行 pleg (pod lifecycle event generator) 模块 <code>kl.pleg</code></li><li>运行主循环 <code>kl.syncLoop</code></li></ul><p><code>kl.syncLoop</code> 接受两个参数，第一个是 <code>&lt;-chan kubetypes.PodUpdate</code>，第二个是 <code>SyncHandler</code>，<code>SyncHandler</code> 定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyncHandler is an interface implemented by Kubelet, for testability</span></span><br><span class="line"><span class="keyword">type</span> SyncHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">HandlePodAdditions(pods []*v1.Pod)</span><br><span class="line">HandlePodUpdates(pods []*v1.Pod)</span><br><span class="line">HandlePodRemoves(pods []*v1.Pod)</span><br><span class="line">HandlePodReconcile(pods []*v1.Pod)</span><br><span class="line">HandlePodSyncs(pods []*v1.Pod)</span><br><span class="line">HandlePodCleanups() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>kl.syncLoop</code> 中调用了 <code>kl.syncLoopIteration</code>，接收了以下几种 chan：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- configCh       &lt;-chan kubetypes.PodUpdate</span><br><span class="line">- syncCh         &lt;-chan time.Time，定时触发的 resync 操作</span><br><span class="line">- housekeepingCh &lt;-chan time.Time，定时触发的清理操作</span><br><span class="line">- plegCh         &lt;-chan *pleg.PodLifecycleEvent</span><br></pre></td></tr></table></figure><p>其中 <code>configCh</code> 会触发 <code>HandlePodAdditions</code>，<code>HandlePodUpdates</code>，<code>HandlePodRemoves</code>，<code>HandlePodReconcile</code> 四种操作。而 <code>syncCh</code> 和 <code>plegCh</code> 会触发 <code>HandlePodSyncs</code> 操作，<code>housekeepingCh</code> 会触发 <code>HandlePodCleanups</code> 操作。</p><p>到这个时候 pod 的生命周期处理的入口基本上找到了，看到这新的问题来了：</p><ul><li><code>&lt;-chan kubetypes.PodUpdate</code> 到底是怎么触发的，对应的四个操作都做了什么</li><li><code>HandlePodSyncs</code> 和上述四个操作什么关系（凭什么你叫 sync）</li><li><code>HandlePodCleanups</code> 和 <code>HandlePodRemoves</code> 的区别</li><li>为什么需要定时触发 <code>syncCh</code></li><li>为什么需要 <code>housekeeping</code></li><li><code>pleg</code> 模块到底做了什么</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Version&quot;&gt;&lt;a href=&quot;#Version&quot; class=&quot;headerlink&quot; title=&quot;Version&quot;&gt;&lt;/a&gt;Version&lt;/h2&gt;&lt;p&gt;v1.12.4&lt;/p&gt;&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;面试被问 pod 的生命周期，说到 kubelet 创建 pod 的部分时只提了 kubelet 发 API 给 docker 创建 container，被认为对 kubernetes 不够熟悉。&lt;br&gt;想了想接触 kubernetes 这么多年了，确实没有真的系统的看过所有代码，认了，查漏补缺吧，挨个写写 kubernetes 的这些个核心组件。&lt;br&gt;之所以用 1.12.4 是因为本地恰好用的 1.12.4，如果 1.14 有想关注的更新会额外写 blog。&lt;/p&gt;&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;kubelet 是什么就不说了，它的主要代码集中在 kubernetes 项目下的 &lt;code&gt;/pkg/kubelet&lt;/code&gt; 位置，总的来说项目结构是相当的清晰。下面是一级目录的简单说明。&lt;/p&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="https://liubog2008.github.io/categories/kubernetes/"/>
    
      <category term="code" scheme="https://liubog2008.github.io/categories/kubernetes/code/"/>
    
    
      <category term="kubernetes" scheme="https://liubog2008.github.io/tags/kubernetes/"/>
    
      <category term="kubelet" scheme="https://liubog2008.github.io/tags/kubelet/"/>
    
  </entry>
  
  <entry>
    <title>Rust 学习历程（二）</title>
    <link href="https://liubog2008.github.io/2019/02/25/learn-rust-two/"/>
    <id>https://liubog2008.github.io/2019/02/25/learn-rust-two/</id>
    <published>2019-02-25T13:46:43.000Z</published>
    <updated>2019-02-25T13:52:00.449Z</updated>
    
    <content type="html"><![CDATA[<p>提到 rust 不得不提的就是 rust 的 <code>ownership</code> 机制，坦白来讲如果不是 <code>ownership</code> 我一定不会对 rust 感兴趣。</p><h2 id="What’s-ownership"><a href="#What’s-ownership" class="headerlink" title="What’s ownership"></a>What’s ownership</h2><p>ownership 是 rust 用来解决内存回收问题的方案，现阶段关于堆内存的回收主要有三种方案：</p><ul><li>手动回收，高性能的中古时代的语言如 C/C++ 等都是如此。</li><li>垃圾回收，极大的降低了程序员心智负担，同时在一定程度上提高了程序的资源消耗。</li><li>rust 的 ownership 方案，通过规定 ownership 来确保离开作用域时自动回收内存。</li></ul><p>总的来说 <code>ownership</code> 就是 rust 用来解决内存回收问题的方案 —— 像栈变量一样离开作用域就被回收，并因此规定所有的堆变量只有一个 <code>owner</code>。</p><a id="more"></a><h2 id="Why-only-one-owner"><a href="#Why-only-one-owner" class="headerlink" title="Why only one owner"></a>Why only one owner</h2><p>堆变量只有一个 <code>owner</code> 是什么意思呢？简单来说就是无法给一个堆变量两个名字。如下面的代码：<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// failed because of s1 has been moved</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, world!"</span>, s1);</span><br></pre></td></tr></table></figure><p></p><p>这段代码非常好的体现了 <code>ownership</code> 的概念，<code>s1</code> 和 <code>s2</code> 不能同时作为 String 中 <code>hello</code> 的 <code>owner</code>。在将 <code>s1</code> 赋值给 <code>s2</code> 时 <code>hello</code> 的 <code>owner</code> 发生了变化。</p><p>那么为什么要做出这种不太方便的规定呢？本质上是为了避免多个 <code>owner</code> 带来的二次回收问题。如果 <code>s1</code> 和 <code>s2</code> 都拥有 <code>hello</code> 的 reference 的话，在回收 <code>s1</code> 和 <code>s2</code> 时 <code>hello</code> 会被回收两次。</p><h2 id="Mutable"><a href="#Mutable" class="headerlink" title="Mutable"></a>Mutable</h2><p>rust 规定了变量默认是 immutable 的，类似 <code>const</code> 关键字。然后用 <code>mut</code> 变量定义了可以被修改的变量。</p><p>见识少的我第一次发现有语言是这么设计的，但是很快我发现这种设定的一个小优点，它解决了用指针传递变量时不清楚函数是否会修改入参的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := A&#123;&#125;</span><br><span class="line"><span class="comment">// Is x changed?</span></span><br><span class="line">thirdParty(&amp;x)</span><br></pre></td></tr></table></figure><p>当然 c++ 通过 <code>const</code> 来定义有同样的效果，不过根据程序猿惯性定律——是否使用某特性都不影响程序运行时总是倾向不使用。<code>mut</code> 很好的降低了心智负担——不需要考虑哪些参数要加 <code>mut</code>，因为不加跑不起来，不像 <code>const</code> 加不加都能跑。另外个人认为默认 immutable 比默认 mutable 能更好的避免很多的错误。</p><p>当然， golang 表示这不重要，C 对此表示赞同。</p><p>以下是一些函数定义，可以很明显的发现只有第三种加了 <code>mut</code> 关键字的函数我们才需要关心数据是否发生改变。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(s: <span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// also error</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">changeWithRef</span></span>(s: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">changeWithMutRef</span></span>(s: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Is-it-out-of-scope"><a href="#Is-it-out-of-scope" class="headerlink" title="Is it out of scope?"></a>Is it out of scope?</h2><p>rust 的 <code>ownership</code> 机制带来了很多有趣的问题，写 rust 时经常需要判断某个变量是否 <code>out of scope</code></p><p>现在我们定义了一个 String, 然后将这个 String 传入一个函数，什么情况下这个 String 能够离开这个函数而不被回收呢？</p><p>存在以下四种情况：</p><ul><li><code>fn a(s: String)</code>: 回收，不可改</li><li><code>fn b(s: &amp;String)</code>: 不回收，不可改</li><li><code>fn c(s: mut String)</code>: 回收，可以改，改不改都一样</li><li><code>fn d(s: &amp;mut String)</code>: 不回收，可以改</li></ul><p>这里引入了一个 <code>borrow</code> 和 <code>reference</code> (<code>&amp;String</code>) 的概念。<code>reference</code> 指向某个变量但是不会修改它的 <code>ownership</code>。这种行为被称为 <code>borrow</code> 借用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// borrow s</span></span><br><span class="line"><span class="keyword">let</span> refer = &amp;s;</span><br><span class="line">try_change_owner(refer);</span><br><span class="line"><span class="comment">// it's ok to print refer</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, refer);</span><br></pre></td></tr></table></figure><h2 id="By-the-way"><a href="#By-the-way" class="headerlink" title="By the way"></a>By the way</h2><ul><li>rust 的 ownership 可以说是非常有趣，但是它也极大的提高了写代码的心智负担，特别是在还不熟悉的时候。</li><li>有一些特殊情况下某些变量可能需要多个 owner (比如 graph 之类的数据结构)，此时可以通过 rust 的 <code>Rc&lt;T&gt;</code> 来解决。</li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>感觉写 rust 前要先画个图了，一个不小心 ownership 就被挪走了，特别是实现一些指来指去的的数据结构时。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到 rust 不得不提的就是 rust 的 &lt;code&gt;ownership&lt;/code&gt; 机制，坦白来讲如果不是 &lt;code&gt;ownership&lt;/code&gt; 我一定不会对 rust 感兴趣。&lt;/p&gt;&lt;h2 id=&quot;What’s-ownership&quot;&gt;&lt;a href=&quot;#What’s-ownership&quot; class=&quot;headerlink&quot; title=&quot;What’s ownership&quot;&gt;&lt;/a&gt;What’s ownership&lt;/h2&gt;&lt;p&gt;ownership 是 rust 用来解决内存回收问题的方案，现阶段关于堆内存的回收主要有三种方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;手动回收，高性能的中古时代的语言如 C/C++ 等都是如此。&lt;/li&gt;&lt;li&gt;垃圾回收，极大的降低了程序员心智负担，同时在一定程度上提高了程序的资源消耗。&lt;/li&gt;&lt;li&gt;rust 的 ownership 方案，通过规定 ownership 来确保离开作用域时自动回收内存。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总的来说 &lt;code&gt;ownership&lt;/code&gt; 就是 rust 用来解决内存回收问题的方案 —— 像栈变量一样离开作用域就被回收，并因此规定所有的堆变量只有一个 &lt;code&gt;owner&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://liubog2008.github.io/categories/language/"/>
    
      <category term="rust" scheme="https://liubog2008.github.io/categories/language/rust/"/>
    
    
      <category term="rust" scheme="https://liubog2008.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RBAC 以及权限设计 (一)</title>
    <link href="https://liubog2008.github.io/2019/02/20/rbac-one/"/>
    <id>https://liubog2008.github.io/2019/02/20/rbac-one/</id>
    <published>2019-02-20T15:35:51.000Z</published>
    <updated>2019-02-20T15:41:55.249Z</updated>
    
    <content type="html"><![CDATA[<p>权限设计真的是一个大坑，对整个权限模型的理解和 <code>Best Practise</code> 的思考花费了我相当多的时间，因此想要对其做一个记录和总结。本文主要针对系统设计时如何处理权限设计做一个理论上的思考以及实践上的反思，并希望能够针对权限设计探讨一定场景下的 <code>Best Practise</code></p><a id="more"></a><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="AuthZ"><a href="#AuthZ" class="headerlink" title="AuthZ"></a>AuthZ</h3><p>我们在提到权限设计的时候通常是指 <code>Authorization</code> 阶段，这个阶段在用户认证之后，接下来我们需要判断用户能够访问什么资源。不同于 <code>AuthN</code> 有很多的标准方案，<code>AuthZ</code> 几乎只有几个寥寥的理论模型，并且几乎都会对业务设计带来影响。</p><h3 id="Subject-amp-Permission"><a href="#Subject-amp-Permission" class="headerlink" title="Subject &amp; Permission"></a>Subject &amp; Permission</h3><p>权限主体 (subject) 往往是指权限的拥有对象。它可以代表一个用户，一个群组，甚至一个更大的组织架构。</p><p>权限 (permission) 是一个抽象概念，它可以是能否访问某个 API，也可以是能否展示某个 UI 组件。通常意义上来说权限可以分为数据权限和功能权限 (我只在某个中文 blog 里看到过这种分法，不知道是否有理论支撑，不过个人感觉还是挺合理的)。</p><p>功能权限通常指能不能做某件事，比如能不能访问某个 API。而数据权限通常指能做到什么程度，比如访问金额 20000 以上的订单。二者的区别在于功能权限的边界相对确定 (比如能否访问订单一般不会变为能否访问购物车)，而数据权限常常是模糊的，不可数的，不可预料的 (比如 20000 以上的订单可能会变化，反复分割，甚至自定义)</p><p>这里引入一个资源的概念，权限可以抽象为<code>对资源的访问能力</code>。那么功能权限可以认为对资源是无感知的，权限系统不关心资源是什么，长什么样。而数据权限对资源有感知，它往往需要知道资源的某些特征，并针对性的设计。</p><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>RBAC 是一种权限设计的理论模型，有以下四种子模型，功能依次增强。<a href="http://www.woshipm.com/pd/440765.html" target="_blank" rel="noopener">这是一篇 RBAC 模型的介绍</a> (是我看到的关于 RBAC 的中文文章中最好的几篇之一)。</p><ul><li>RBAC0</li><li>RBAC1</li><li>RBAC2</li><li>RBAC3</li></ul><p>TODO: 详细讨论一下 RBAC 的四种子模型的区别。</p><p>RBAC 的理论核心就是将权限 (permission) 和权限主体 (subject) 之间添加一层角色 (role) 来实现权限分配和设计的解耦。</p><blockquote><p>All problems in computer science can be solved by another level of indirection.<br>– David Wheeler</p></blockquote><p>RBAC 成功的解决了 <code>subject</code> 和 <code>permission</code> 直接关联时权限粒度过细带来的分配困难 (每建立一个 subject 都需要绑定非常多个 permission) 以及权限修改带来的再分配困难 (每增加一个 permission 都可能需要修改 subject 和新 permission 的绑定)。</p><h2 id="RBAC-实践问题总结"><a href="#RBAC-实践问题总结" class="headerlink" title="RBAC 实践问题总结"></a>RBAC 实践问题总结</h2><p>在 RBAC 的实践过程中我们遇到了如下问题：</p><ul><li>通用化 or 业务化</li><li>如何定义 permission<ul><li>如何处理 UI 组件访问权限</li><li>如何处理 API 访问权限</li></ul></li><li>如何处理数据权限</li><li>权限分配功能的权限设计</li><li>多个角色间的权限聚合问题</li></ul><p>TODO: 挨个总结</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;权限设计真的是一个大坑，对整个权限模型的理解和 &lt;code&gt;Best Practise&lt;/code&gt; 的思考花费了我相当多的时间，因此想要对其做一个记录和总结。本文主要针对系统设计时如何处理权限设计做一个理论上的思考以及实践上的反思，并希望能够针对权限设计探讨一定场景下的 &lt;code&gt;Best Practise&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="design" scheme="https://liubog2008.github.io/categories/design/"/>
    
      <category term="rbac" scheme="https://liubog2008.github.io/categories/design/rbac/"/>
    
    
      <category term="design" scheme="https://liubog2008.github.io/tags/design/"/>
    
      <category term="best practise" scheme="https://liubog2008.github.io/tags/best-practise/"/>
    
      <category term="rbac" scheme="https://liubog2008.github.io/tags/rbac/"/>
    
      <category term="authz" scheme="https://liubog2008.github.io/tags/authz/"/>
    
  </entry>
  
  <entry>
    <title>Rust 学习历程（一）</title>
    <link href="https://liubog2008.github.io/2019/02/18/learn-rust-one/"/>
    <id>https://liubog2008.github.io/2019/02/18/learn-rust-one/</id>
    <published>2019-02-18T12:43:07.000Z</published>
    <updated>2019-02-18T12:51:33.652Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要学习 rust，记录一下 rust 的学习历程。预计最终目标是用 rust 完成一个简单的 os 内核。由于个人 golang 用的比较多，会尽可能将 rust 相关的功能和 golang 进行对比。</p><p>希望能通过 rust 接触更多的编程思想，golang 写的都不会用范型了。</p><p>NOTE: 整个学习历程可能会比较跳跃</p><a id="more"></a><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>安装 rust 一帆风顺，cargo 还是很好用的 (当然可能是短期内没有踩到坑)。rust 的包管理几乎完爆了 golang，想起过去折腾 golang 的包管理还是很心累。再一想到过段时间可能又要从 dep 换掉真的令人内心爆炸。</p><p>以下是 rust hello world!<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>关于这段程序，我遇到了三个问题：</p><ol><li><code>println</code> 为什么后面加了 <code>!</code></li><li>最后的分号是否可选</li><li><code>println</code> 文档在哪</li></ol><h2 id="Marco"><a href="#Marco" class="headerlink" title="Marco"></a>Marco</h2><h3 id="macro-rules"><a href="#macro-rules" class="headerlink" title="macro_rules!"></a>macro_rules!</h3><p><code>println!</code> 表示这个是一个 <code>macro</code>。这让我想起了被 C 的 <code>#define</code> 支配的日子。<code>macro</code> 本质就是代码替换，但是骚操作太多，很多语言完全放弃了 macro 这种特性（比如 golang）。</p><p>rust 中 <code>macro</code> 的语法如下，<code>( $( $x:expr ),* )</code> 涉及到了 <strong>模式匹配</strong> 的概念。</p><p>TODO: 模式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>macro</code> 展开后如下，其中 <code>$()*</code> 类似 regex，表示生成任意次，次数对应匹配 <code>( $( $x:expr ),* )</code> 多少次，匹配 <code>1, 2, 3</code> 就生成了 3 次。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">    temp_vec.push(<span class="number">1</span>);</span><br><span class="line">    temp_vec.push(<span class="number">2</span>);</span><br><span class="line">    temp_vec.push(<span class="number">3</span>);</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后小萌新突然发现 rust 说 <code>macro_ruls!</code> 有很多问题，会被废弃。<br>emmmm… 反正 golang 都甚至没有 <code>macro</code></p><h3 id="procedural-macro"><a href="#procedural-macro" class="headerlink" title="procedural macro"></a>procedural macro</h3><p>还有一种 macro 叫做 procedural macro，有以下三种情况</p><ul><li>Custom <code>#[derive]</code> macros</li><li>Attribute-like macros</li><li>Function-like macros</li></ul><p>和上面的 <code>macro_rule</code> 的区别在于不是单纯的代码段替换而是接受一段 rust 代码后输出一段 rust 代码（感觉是可以自定义 macro template 逻辑的意思）</p><p>TODO: procedural macro 详解</p><h2 id="Statement-Or-Expression"><a href="#Statement-Or-Expression" class="headerlink" title="Statement Or Expression"></a>Statement Or Expression</h2><p>rust 被称为 <strong>expression language</strong>，<code>statement</code> 和 <code>expression</code> 最主要的区别在于 <code>expression</code> 总是返回值。</p><p>在 rust 中 <code>statement</code> 有以下几种</p><ul><li>Item: 类似各种 <code>fn</code> 之类的声明</li><li>LetStatement: <code>let</code> 语句</li><li>ExpressionStatement: <strong>所有的 <code>expression</code> 加上 <code>;</code> 后就成了 <code>statment</code></strong></li><li>MacroInvocationSemi: <code>macro</code> 相关的调用语句</li></ul><h3 id="Why-println-without-can-be-compiled"><a href="#Why-println-without-can-be-compiled" class="headerlink" title="Why println! without ; can be compiled"></a>Why println! without ; can be compiled</h3><p><code>Hello World</code> 中 <code>println!</code> 语句的最后是可以不添加分号的，原因是 rust 默认返回最后一个 <code>expression</code> 的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// it's ok</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ok</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">"aaa"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it's also ok</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">alsoOk</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">"aaa"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"aaa"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it's error, because expression only can be the last of fn</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">err</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">"aaa"</span>)</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外 rust 中还有一个<strong>设定是 <code>statement</code> 会返回 <code>()</code></strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x is [1,2,3]</span></span><br><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">    <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y is ()</span></span><br><span class="line"><span class="keyword">let</span> y = &#123;</span><br><span class="line">    <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>个人感觉这个操作挺迷的。</p><h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p><a href="https://doc.rust-lang.org/std/macro.println.html" target="_blank" rel="noopener">println 文档</a></p><p>文档的直观感觉还是很不错的。</p><h2 id="At-Last"><a href="#At-Last" class="headerlink" title="At Last"></a>At Last</h2><p>TODOs:</p><ul><li>模式匹配</li><li>procedural macro 详解</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想要学习 rust，记录一下 rust 的学习历程。预计最终目标是用 rust 完成一个简单的 os 内核。由于个人 golang 用的比较多，会尽可能将 rust 相关的功能和 golang 进行对比。&lt;/p&gt;&lt;p&gt;希望能通过 rust 接触更多的编程思想，golang 写的都不会用范型了。&lt;/p&gt;&lt;p&gt;NOTE: 整个学习历程可能会比较跳跃&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://liubog2008.github.io/categories/language/"/>
    
      <category term="rust" scheme="https://liubog2008.github.io/categories/language/rust/"/>
    
    
      <category term="rust" scheme="https://liubog2008.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://liubog2008.github.io/2019/02/17/hello-world/"/>
    <id>https://liubog2008.github.io/2019/02/17/hello-world/</id>
    <published>2019-02-17T10:44:48.251Z</published>
    <updated>2019-02-17T10:44:48.251Z</updated>
    
    <content type="html"><![CDATA[<p>Testing the hexo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Testing the hexo&lt;/p&gt;
      
    
    </summary>
    
      <category term="tools" scheme="https://liubog2008.github.io/categories/tools/"/>
    
    
      <category term="tools" scheme="https://liubog2008.github.io/tags/tools/"/>
    
      <category term="hexo" scheme="https://liubog2008.github.io/tags/hexo/"/>
    
      <category term="hexo/next" scheme="https://liubog2008.github.io/tags/hexo-next/"/>
    
  </entry>
  
</feed>
