<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liubog2008.github.io/"/>
  <updated>2019-02-25T13:52:00.449Z</updated>
  <id>https://liubog2008.github.io/</id>
  
  <author>
    <name>liubog2008</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 学习历程（二）</title>
    <link href="https://liubog2008.github.io/2019/02/25/learn-rust-two/"/>
    <id>https://liubog2008.github.io/2019/02/25/learn-rust-two/</id>
    <published>2019-02-25T13:46:43.000Z</published>
    <updated>2019-02-25T13:52:00.449Z</updated>
    
    <content type="html"><![CDATA[<p>提到 rust 不得不提的就是 rust 的 <code>ownership</code> 机制，坦白来讲如果不是 <code>ownership</code> 我一定不会对 rust 感兴趣。</p><h2 id="What’s-ownership"><a href="#What’s-ownership" class="headerlink" title="What’s ownership"></a>What’s ownership</h2><p>ownership 是 rust 用来解决内存回收问题的方案，现阶段关于堆内存的回收主要有三种方案：</p><ul><li>手动回收，高性能的中古时代的语言如 C/C++ 等都是如此。</li><li>垃圾回收，极大的降低了程序员心智负担，同时在一定程度上提高了程序的资源消耗。</li><li>rust 的 ownership 方案，通过规定 ownership 来确保离开作用域时自动回收内存。</li></ul><p>总的来说 <code>ownership</code> 就是 rust 用来解决内存回收问题的方案 —— 像栈变量一样离开作用域就被回收，并因此规定所有的堆变量只有一个 <code>owner</code>。</p><a id="more"></a><h2 id="Why-only-one-owner"><a href="#Why-only-one-owner" class="headerlink" title="Why only one owner"></a>Why only one owner</h2><p>堆变量只有一个 <code>owner</code> 是什么意思呢？简单来说就是无法给一个堆变量两个名字。如下面的代码：<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// failed because of s1 has been moved</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, world!"</span>, s1);</span><br></pre></td></tr></table></figure><p></p><p>这段代码非常好的体现了 <code>ownership</code> 的概念，<code>s1</code> 和 <code>s2</code> 不能同时作为 String 中 <code>hello</code> 的 <code>owner</code>。在将 <code>s1</code> 赋值给 <code>s2</code> 时 <code>hello</code> 的 <code>owner</code> 发生了变化。</p><p>那么为什么要做出这种不太方便的规定呢？本质上是为了避免多个 <code>owner</code> 带来的二次回收问题。如果 <code>s1</code> 和 <code>s2</code> 都拥有 <code>hello</code> 的 reference 的话，在回收 <code>s1</code> 和 <code>s2</code> 时 <code>hello</code> 会被回收两次。</p><h2 id="Mutable"><a href="#Mutable" class="headerlink" title="Mutable"></a>Mutable</h2><p>rust 规定了变量默认是 immutable 的，类似 <code>const</code> 关键字。然后用 <code>mut</code> 变量定义了可以被修改的变量。</p><p>见识少的我第一次发现有语言是这么设计的，但是很快我发现这种设定的一个小优点，它解决了用指针传递变量时不清楚函数是否会修改入参的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := A&#123;&#125;</span><br><span class="line"><span class="comment">// Is x changed?</span></span><br><span class="line">thirdParty(&amp;x)</span><br></pre></td></tr></table></figure><p>当然 c++ 通过 <code>const</code> 来定义有同样的效果，不过根据程序猿惯性定律——是否使用某特性都不影响程序运行时总是倾向不使用。<code>mut</code> 很好的降低了心智负担——不需要考虑哪些参数要加 <code>mut</code>，因为不加跑不起来，不像 <code>const</code> 加不加都能跑。另外个人认为默认 immutable 比默认 mutable 能更好的避免很多的错误。</p><p>当然， golang 表示这不重要，C 对此表示赞同。</p><p>以下是一些函数定义，可以很明显的发现只有第三种加了 <code>mut</code> 关键字的函数我们才需要关心数据是否发生改变。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(s: <span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// also error</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">changeWithRef</span></span>(s: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">changeWithMutRef</span></span>(s: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Is-it-out-of-scope"><a href="#Is-it-out-of-scope" class="headerlink" title="Is it out of scope?"></a>Is it out of scope?</h2><p>rust 的 <code>ownership</code> 机制带来了很多有趣的问题，写 rust 时经常需要判断某个变量是否 <code>out of scope</code></p><p>现在我们定义了一个 String, 然后将这个 String 传入一个函数，什么情况下这个 String 能够离开这个函数而不被回收呢？</p><p>存在以下四种情况：</p><ul><li><code>fn a(s: String)</code>: 回收，不可改</li><li><code>fn b(s: &amp;String)</code>: 不回收，不可改</li><li><code>fn c(s: mut String)</code>: 回收，可以改，改不改都一样</li><li><code>fn d(s: &amp;mut String)</code>: 不回收，可以改</li></ul><p>这里引入了一个 <code>borrow</code> 和 <code>reference</code> (<code>&amp;String</code>) 的概念。<code>reference</code> 指向某个变量但是不会修改它的 <code>ownership</code>。这种行为被称为 <code>borrow</code> 借用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// borrow s</span></span><br><span class="line"><span class="keyword">let</span> refer = &amp;s;</span><br><span class="line">try_change_owner(refer);</span><br><span class="line"><span class="comment">// it's ok to print refer</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, refer);</span><br></pre></td></tr></table></figure><h2 id="By-the-way"><a href="#By-the-way" class="headerlink" title="By the way"></a>By the way</h2><ul><li>rust 的 ownership 可以说是非常有趣，但是它也极大的提高了写代码的心智负担，特别是在还不熟悉的时候。</li><li>有一些特殊情况下某些变量可能需要多个 owner (比如 graph 之类的数据结构)，此时可以通过 rust 的 <code>Rc&lt;T&gt;</code> 来解决。</li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>感觉写 rust 前要先画个图了，一个不小心 ownership 就被挪走了，特别是实现一些指来指去的的数据结构时。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到 rust 不得不提的就是 rust 的 &lt;code&gt;ownership&lt;/code&gt; 机制，坦白来讲如果不是 &lt;code&gt;ownership&lt;/code&gt; 我一定不会对 rust 感兴趣。&lt;/p&gt;&lt;h2 id=&quot;What’s-ownership&quot;&gt;&lt;a href=&quot;#What’s-ownership&quot; class=&quot;headerlink&quot; title=&quot;What’s ownership&quot;&gt;&lt;/a&gt;What’s ownership&lt;/h2&gt;&lt;p&gt;ownership 是 rust 用来解决内存回收问题的方案，现阶段关于堆内存的回收主要有三种方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;手动回收，高性能的中古时代的语言如 C/C++ 等都是如此。&lt;/li&gt;&lt;li&gt;垃圾回收，极大的降低了程序员心智负担，同时在一定程度上提高了程序的资源消耗。&lt;/li&gt;&lt;li&gt;rust 的 ownership 方案，通过规定 ownership 来确保离开作用域时自动回收内存。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总的来说 &lt;code&gt;ownership&lt;/code&gt; 就是 rust 用来解决内存回收问题的方案 —— 像栈变量一样离开作用域就被回收，并因此规定所有的堆变量只有一个 &lt;code&gt;owner&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://liubog2008.github.io/categories/language/"/>
    
      <category term="rust" scheme="https://liubog2008.github.io/categories/language/rust/"/>
    
    
      <category term="rust" scheme="https://liubog2008.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RBAC 以及权限设计 (一)</title>
    <link href="https://liubog2008.github.io/2019/02/20/rbac-one/"/>
    <id>https://liubog2008.github.io/2019/02/20/rbac-one/</id>
    <published>2019-02-20T15:35:51.000Z</published>
    <updated>2019-02-20T15:41:55.249Z</updated>
    
    <content type="html"><![CDATA[<p>权限设计真的是一个大坑，对整个权限模型的理解和 <code>Best Practise</code> 的思考花费了我相当多的时间，因此想要对其做一个记录和总结。本文主要针对系统设计时如何处理权限设计做一个理论上的思考以及实践上的反思，并希望能够针对权限设计探讨一定场景下的 <code>Best Practise</code></p><a id="more"></a><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="AuthZ"><a href="#AuthZ" class="headerlink" title="AuthZ"></a>AuthZ</h3><p>我们在提到权限设计的时候通常是指 <code>Authorization</code> 阶段，这个阶段在用户认证之后，接下来我们需要判断用户能够访问什么资源。不同于 <code>AuthN</code> 有很多的标准方案，<code>AuthZ</code> 几乎只有几个寥寥的理论模型，并且几乎都会对业务设计带来影响。</p><h3 id="Subject-amp-Permission"><a href="#Subject-amp-Permission" class="headerlink" title="Subject &amp; Permission"></a>Subject &amp; Permission</h3><p>权限主体 (subject) 往往是指权限的拥有对象。它可以代表一个用户，一个群组，甚至一个更大的组织架构。</p><p>权限 (permission) 是一个抽象概念，它可以是能否访问某个 API，也可以是能否展示某个 UI 组件。通常意义上来说权限可以分为数据权限和功能权限 (我只在某个中文 blog 里看到过这种分法，不知道是否有理论支撑，不过个人感觉还是挺合理的)。</p><p>功能权限通常指能不能做某件事，比如能不能访问某个 API。而数据权限通常指能做到什么程度，比如访问金额 20000 以上的订单。二者的区别在于功能权限的边界相对确定 (比如能否访问订单一般不会变为能否访问购物车)，而数据权限常常是模糊的，不可数的，不可预料的 (比如 20000 以上的订单可能会变化，反复分割，甚至自定义)</p><p>这里引入一个资源的概念，权限可以抽象为<code>对资源的访问能力</code>。那么功能权限可以认为对资源是无感知的，权限系统不关心资源是什么，长什么样。而数据权限对资源有感知，它往往需要知道资源的某些特征，并针对性的设计。</p><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>RBAC 是一种权限设计的理论模型，有以下四种子模型，功能依次增强。<a href="http://www.woshipm.com/pd/440765.html" target="_blank" rel="noopener">这是一篇 RBAC 模型的介绍</a> (是我看到的关于 RBAC 的中文文章中最好的几篇之一)。</p><ul><li>RBAC0</li><li>RBAC1</li><li>RBAC2</li><li>RBAC3</li></ul><p>TODO: 详细讨论一下 RBAC 的四种子模型的区别。</p><p>RBAC 的理论核心就是将权限 (permission) 和权限主体 (subject) 之间添加一层角色 (role) 来实现权限分配和设计的解耦。</p><blockquote><p>All problems in computer science can be solved by another level of indirection.<br>– David Wheeler</p></blockquote><p>RBAC 成功的解决了 <code>subject</code> 和 <code>permission</code> 直接关联时权限粒度过细带来的分配困难 (每建立一个 subject 都需要绑定非常多个 permission) 以及权限修改带来的再分配困难 (每增加一个 permission 都可能需要修改 subject 和新 permission 的绑定)。</p><h2 id="RBAC-实践问题总结"><a href="#RBAC-实践问题总结" class="headerlink" title="RBAC 实践问题总结"></a>RBAC 实践问题总结</h2><p>在 RBAC 的实践过程中我们遇到了如下问题：</p><ul><li>通用化 or 业务化</li><li>如何定义 permission<ul><li>如何处理 UI 组件访问权限</li><li>如何处理 API 访问权限</li></ul></li><li>如何处理数据权限</li><li>权限分配功能的权限设计</li><li>多个角色间的权限聚合问题</li></ul><p>TODO: 挨个总结</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;权限设计真的是一个大坑，对整个权限模型的理解和 &lt;code&gt;Best Practise&lt;/code&gt; 的思考花费了我相当多的时间，因此想要对其做一个记录和总结。本文主要针对系统设计时如何处理权限设计做一个理论上的思考以及实践上的反思，并希望能够针对权限设计探讨一定场景下的 &lt;code&gt;Best Practise&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="design" scheme="https://liubog2008.github.io/categories/design/"/>
    
      <category term="rbac" scheme="https://liubog2008.github.io/categories/design/rbac/"/>
    
    
      <category term="design" scheme="https://liubog2008.github.io/tags/design/"/>
    
      <category term="best practise" scheme="https://liubog2008.github.io/tags/best-practise/"/>
    
      <category term="rbac" scheme="https://liubog2008.github.io/tags/rbac/"/>
    
      <category term="authz" scheme="https://liubog2008.github.io/tags/authz/"/>
    
  </entry>
  
  <entry>
    <title>Rust 学习历程（一）</title>
    <link href="https://liubog2008.github.io/2019/02/18/learn-rust-one/"/>
    <id>https://liubog2008.github.io/2019/02/18/learn-rust-one/</id>
    <published>2019-02-18T12:43:07.000Z</published>
    <updated>2019-02-18T12:51:33.652Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要学习 rust，记录一下 rust 的学习历程。预计最终目标是用 rust 完成一个简单的 os 内核。由于个人 golang 用的比较多，会尽可能将 rust 相关的功能和 golang 进行对比。</p><p>希望能通过 rust 接触更多的编程思想，golang 写的都不会用范型了。</p><p>NOTE: 整个学习历程可能会比较跳跃</p><a id="more"></a><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>安装 rust 一帆风顺，cargo 还是很好用的 (当然可能是短期内没有踩到坑)。rust 的包管理几乎完爆了 golang，想起过去折腾 golang 的包管理还是很心累。再一想到过段时间可能又要从 dep 换掉真的令人内心爆炸。</p><p>以下是 rust hello world!<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>关于这段程序，我遇到了三个问题：</p><ol><li><code>println</code> 为什么后面加了 <code>!</code></li><li>最后的分号是否可选</li><li><code>println</code> 文档在哪</li></ol><h2 id="Marco"><a href="#Marco" class="headerlink" title="Marco"></a>Marco</h2><h3 id="macro-rules"><a href="#macro-rules" class="headerlink" title="macro_rules!"></a>macro_rules!</h3><p><code>println!</code> 表示这个是一个 <code>macro</code>。这让我想起了被 C 的 <code>#define</code> 支配的日子。<code>macro</code> 本质就是代码替换，但是骚操作太多，很多语言完全放弃了 macro 这种特性（比如 golang）。</p><p>rust 中 <code>macro</code> 的语法如下，<code>( $( $x:expr ),* )</code> 涉及到了 <strong>模式匹配</strong> 的概念。</p><p>TODO: 模式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>macro</code> 展开后如下，其中 <code>$()*</code> 类似 regex，表示生成任意次，次数对应匹配 <code>( $( $x:expr ),* )</code> 多少次，匹配 <code>1, 2, 3</code> 就生成了 3 次。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">    temp_vec.push(<span class="number">1</span>);</span><br><span class="line">    temp_vec.push(<span class="number">2</span>);</span><br><span class="line">    temp_vec.push(<span class="number">3</span>);</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后小萌新突然发现 rust 说 <code>macro_ruls!</code> 有很多问题，会被废弃。<br>emmmm… 反正 golang 都甚至没有 <code>macro</code></p><h3 id="procedural-macro"><a href="#procedural-macro" class="headerlink" title="procedural macro"></a>procedural macro</h3><p>还有一种 macro 叫做 procedural macro，有以下三种情况</p><ul><li>Custom <code>#[derive]</code> macros</li><li>Attribute-like macros</li><li>Function-like macros</li></ul><p>和上面的 <code>macro_rule</code> 的区别在于不是单纯的代码段替换而是接受一段 rust 代码后输出一段 rust 代码（感觉是可以自定义 macro template 逻辑的意思）</p><p>TODO: procedural macro 详解</p><h2 id="Statement-Or-Expression"><a href="#Statement-Or-Expression" class="headerlink" title="Statement Or Expression"></a>Statement Or Expression</h2><p>rust 被称为 <strong>expression language</strong>，<code>statement</code> 和 <code>expression</code> 最主要的区别在于 <code>expression</code> 总是返回值。</p><p>在 rust 中 <code>statement</code> 有以下几种</p><ul><li>Item: 类似各种 <code>fn</code> 之类的声明</li><li>LetStatement: <code>let</code> 语句</li><li>ExpressionStatement: <strong>所有的 <code>expression</code> 加上 <code>;</code> 后就成了 <code>statment</code></strong></li><li>MacroInvocationSemi: <code>macro</code> 相关的调用语句</li></ul><h3 id="Why-println-without-can-be-compiled"><a href="#Why-println-without-can-be-compiled" class="headerlink" title="Why println! without ; can be compiled"></a>Why println! without ; can be compiled</h3><p><code>Hello World</code> 中 <code>println!</code> 语句的最后是可以不添加分号的，原因是 rust 默认返回最后一个 <code>expression</code> 的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// it's ok</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ok</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">"aaa"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it's also ok</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">alsoOk</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">"aaa"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"aaa"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it's error, because expression only can be the last of fn</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">err</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">"aaa"</span>)</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外 rust 中还有一个<strong>设定是 <code>statement</code> 会返回 <code>()</code></strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x is [1,2,3]</span></span><br><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">    <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y is ()</span></span><br><span class="line"><span class="keyword">let</span> y = &#123;</span><br><span class="line">    <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>个人感觉这个操作挺迷的。</p><h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p><a href="https://doc.rust-lang.org/std/macro.println.html" target="_blank" rel="noopener">println 文档</a></p><p>文档的直观感觉还是很不错的。</p><h2 id="At-Last"><a href="#At-Last" class="headerlink" title="At Last"></a>At Last</h2><p>TODOs:</p><ul><li>模式匹配</li><li>procedural macro 详解</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想要学习 rust，记录一下 rust 的学习历程。预计最终目标是用 rust 完成一个简单的 os 内核。由于个人 golang 用的比较多，会尽可能将 rust 相关的功能和 golang 进行对比。&lt;/p&gt;&lt;p&gt;希望能通过 rust 接触更多的编程思想，golang 写的都不会用范型了。&lt;/p&gt;&lt;p&gt;NOTE: 整个学习历程可能会比较跳跃&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://liubog2008.github.io/categories/language/"/>
    
      <category term="rust" scheme="https://liubog2008.github.io/categories/language/rust/"/>
    
    
      <category term="rust" scheme="https://liubog2008.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://liubog2008.github.io/2019/02/17/hello-world/"/>
    <id>https://liubog2008.github.io/2019/02/17/hello-world/</id>
    <published>2019-02-17T10:44:48.251Z</published>
    <updated>2019-02-17T10:44:48.251Z</updated>
    
    <content type="html"><![CDATA[<p>Testing the hexo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Testing the hexo&lt;/p&gt;
      
    
    </summary>
    
      <category term="tools" scheme="https://liubog2008.github.io/categories/tools/"/>
    
    
      <category term="tools" scheme="https://liubog2008.github.io/tags/tools/"/>
    
      <category term="hexo" scheme="https://liubog2008.github.io/tags/hexo/"/>
    
      <category term="hexo/next" scheme="https://liubog2008.github.io/tags/hexo-next/"/>
    
  </entry>
  
</feed>
