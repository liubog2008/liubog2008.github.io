<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liubog2008.github.io/"/>
  <updated>2020-11-30T13:58:44.465Z</updated>
  <id>https://liubog2008.github.io/</id>
  
  <author>
    <name>liubog2008</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes 源码分析之 kubelet(二)</title>
    <link href="https://liubog2008.github.io/2020/11/30/kubernetes/kubelet-2/"/>
    <id>https://liubog2008.github.io/2020/11/30/kubernetes/kubelet-2/</id>
    <published>2020-11-30T13:56:22.000Z</published>
    <updated>2020-11-30T13:58:44.465Z</updated>
    
    <content type="html"><![CDATA[<p>被迫再就业。。。看的代码版本改到 1.18 了</p><h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><p>v1.18.2</p><h2 id="Pod-Lifecycle"><a href="#Pod-Lifecycle" class="headerlink" title="Pod Lifecycle"></a>Pod Lifecycle</h2><h3 id="Pod-Config-Update"><a href="#Pod-Config-Update" class="headerlink" title="Pod Config Update"></a>Pod Config Update</h3><p>本文顺着前文的思路分析一下 <code>&lt;-chan kubetypes.PodUpdate</code> 以及相关的代码。故名思义，PodUpdate 定义了 pod 的相关更新，具体结构如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PodUpdate <span class="keyword">struct</span> &#123;</span><br><span class="line">Pods   []*v1.Pod</span><br><span class="line">Op     PodOperation</span><br><span class="line">Source <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中 <code>PodOperation</code> 有如下几种类型</p><ul><li>SET 全量更新，类似 RESTful 中 PUT 的含义</li><li>ADD 发现一个新的 pod 被添加</li><li>DELETE 发现 pod 准备要被删除，进入 gracefully deleted 阶段</li><li>REMOVE 发现 pod 已经被删除</li><li>UPDATE 发现 pod 合理的更新</li><li>RECONCILE 发现 pod 某些 status 不是预期状态时</li><li>RESTORE checkpoint restore 时</li></ul><p>同时定义了三种 source：</p><ul><li>api</li><li>file</li><li>http</li></ul><p><code>api</code> 是指 watch apiserver 获得的更新，除此外剩余的两种 source 都是为支持 static pod 设计的。</p><p>各个 source 的 update 事件如何获取，如何合并多个 source 的 update 事件等逻辑都在 <code>/pkg/kubelet/config</code> 文件夹下。其中 <code>apiserver.go</code>，<code>http.go</code>，<code>file.go</code> 分别是上述三种 source 的实现。</p><p>阅读 <code>/pkg/kubelet/config</code> 下的代码，我们可以发现从 <code>source</code> 中触发的 <code>PodOperation</code> 都是 <code>SET</code> 的操作，而没有其他的 <code>PodOperation</code>。</p><p>然后在 <code>/pkg/kubelet/config/config.go</code> 中，将 pod 的更新和本地 cache 比较，分类为不同的 <code>PodOperation</code> (详见 <code>merge</code> 函数)</p><p>可以特别注意是否分类到 <code>RECONCILE</code> 类型，是根据 <code>checkAndUpdatePod</code> 和 <code>podsDifferSemantically</code> 两个函数调用来决定的。简单来说就是如果 pod 的 metadata(部分字段，如 label) 和 spec 等没被修改，而 status 被修改了，就会触发 <code>RECONCILE</code></p><p>另外，<code>config.go</code> 里定义了 <code>PodConfigNotificationMode</code>，上述拆分发生在 mode 为 <code>PodConfigNotificationIncremental</code> 时，但是直到目前 mode 都只能是 <code>PodConfigNotificationIncremental</code> (仅在 <code>/pkg/kubelet/kubelet.go</code> 中调用 <code>NewPodConfig</code> 时指定)</p><h3 id="sync-handler"><a href="#sync-handler" class="headerlink" title="sync handler"></a>sync handler</h3><p>再聊一聊上一篇文章中提到的 <code>SyncHandler</code> 接口，接口定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyncHandler is an interface implemented by Kubelet, for testability</span></span><br><span class="line"><span class="keyword">type</span> SyncHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">HandlePodAdditions(pods []*v1.Pod)</span><br><span class="line">HandlePodUpdates(pods []*v1.Pod)</span><br><span class="line">HandlePodRemoves(pods []*v1.Pod)</span><br><span class="line"></span><br><span class="line">HandlePodReconcile(pods []*v1.Pod)</span><br><span class="line">HandlePodSyncs(pods []*v1.Pod)</span><br><span class="line"></span><br><span class="line">HandlePodCleanups() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简单将 <code>SyncHandler</code> 分为三个部分：</p><ol><li>增删改：<code>Additions</code>，<code>Removes</code>, <code>Updates</code></li><li>状态同步：<code>Reconcile</code>，<code>Syncs</code></li><li>清理：<code>Cleanups</code></li></ol><p>其中，增删改比较好理解，不再赘述。而清理的作用就是将 pod 残留的数据删除干净。由于 pod 的删除在很多环节都有可以出问题，因此需要一个 <code>Cleanups</code> 的操作去处理这些出问题的环节，清理数据。</p><p>至于状态同步可以理解为当 API 中的 status 和 kubelet 所获取的真实 status 不同时，kubelet 会更新 API 中的 status 以向实际的 status 靠近 (kubernetes 著名的设计模式，通过更新不断将当前状态向期望状态靠近直到结果收敛)。</p><p>而 <code>Reconcile</code> 和 <code>Syncs</code> 的差别则在于</p><ol><li><code>Reconcile</code> 的主要目的是防止 pod status 的意外修改，而 <code>Syncs</code> 是真正处理 pod 生命周期的核心逻辑。</li><li>由于添加了 <code>ReadinessGate</code> 的 feature， <code>Reconcile</code> 在一定条件下也会触发 sync 操作。</li></ol><p>PS: 从实现上可以看出来 sync 和 reconcile 的定义差别，reconcile 是 kubernetes 开放 API (即无内部 API 调用，所有 API 均可外部调用) 所带来的固有问题的解决方案。而 sync 是 kubernetes 核心设计模式中 actual 向 expected 收敛这一过程的描述。不过现阶段二者的界限已经模糊了，特别在 operator 的设计中已经普遍使用了 reconcile 的说法。</p><p>最后整个 <code>SyncHandler</code> 的实现涉及到两个关键部分，一个是 <code>podManager</code>，一个是 <code>podWorkers</code>。</p><h3 id="podManager"><a href="#podManager" class="headerlink" title="podManager"></a>podManager</h3><p><code>podManager</code> 管理 kubelet 对 pod 的访问，见 <code>pkg/kubelet/pod/pod_manager.go</code>。由于 mirror pod (mirror pod 和 static pod 的关系可以理解为: kubelet 发现一个 static pod 后会在 apiserver 中创建一个 mirror pod) 的存在整个 <code>podManager</code> 显得有些复杂。总的来说 <code>podManager</code> 就是实现了一个内存数据库，用于 cache 多个 source (见上文的 3 种来源) 的 pod，并提供了一些 pod 的查询功能，如：</p><ul><li>从 namespace 和 name 查 pod</li><li>从 uid 查 pod</li><li>根据 pod 查 mirror pod</li><li>根据 mirror pod 查 pod</li><li>等</li></ul><h3 id="podWorkers"><a href="#podWorkers" class="headerlink" title="podWorkers"></a>podWorkers</h3><p><code>podWorkers</code> 定义在 <code>/pkg/kubelet/pod_workers.go</code>，用于分发对 pod 的操作任务，譬如上文中的 <code>SyncHandler</code> 的很多操作最终会调用 <code>dispatchWork</code> 交给 <code>podWorkers</code> 来执行。</p><p>查看 <code>podWorkers</code> 的代码，发现核心逻辑在 <code>syncPodFn</code> 的调用，而这个 <code>syncPodFn</code> 则是在 <code>/pkg/kubelet/kubelet.go</code>中调用 <code>newPodWorkers</code> 时初始化的，其实际上就是 <code>pkg/kubelet/kubelet.go</code> 下的 <code>syncPod</code> 函数。</p><p>如果这个时候你正在看 kubelet 的代码，就会发现 <code>syncPod</code> 上面有很长很长的注释 – 这说明这是一个至关重要的函数。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本次分析回答了之前的一些问题，譬如</p><ul><li><code>&lt;-chan kubetypes.PodUpdate</code> 到底是怎么触发的，对应的四个操作都做了什么</li><li><code>HandlePodSyncs</code> 和上述四个操作什么关系（凭什么你叫 sync）</li><li><code>HandlePodCleanups</code> 和 <code>HandlePodRemoves</code> 的区别</li></ul><p>也带来了新的问题</p><ul><li><code>syncPod</code> 做了一些什么</li></ul><p>最后遗留了这些问题</p><ul><li>为什么需要定时触发 <code>syncCh</code></li><li>为什么需要 <code>housekeeping</code></li><li><code>pleg</code> 模块到底做了什么</li><li><code>syncPod</code> 做了一些什么</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;被迫再就业。。。看的代码版本改到 1.18 了&lt;/p&gt;&lt;h2 id=&quot;Version&quot;&gt;&lt;a href=&quot;#Version&quot; class=&quot;headerlink&quot; title=&quot;Version&quot;&gt;&lt;/a&gt;Version&lt;/h2&gt;&lt;p&gt;v1.18.2&lt;/p&gt;&lt;h2 id=&quot;Pod-Lifecycle&quot;&gt;&lt;a href=&quot;#Pod-Lifecycle&quot; class=&quot;headerlink&quot; title=&quot;Pod Lifecycle&quot;&gt;&lt;/a&gt;Pod Lifecycle&lt;/h2&gt;&lt;h3 id=&quot;Pod-Config-Update&quot;&gt;&lt;a href=&quot;#Pod-Config-Update&quot; class=&quot;headerlink&quot; title=&quot;Pod Config Update&quot;&gt;&lt;/a&gt;Pod Config Update&lt;/h3&gt;&lt;p&gt;本文顺着前文的思路分析一下 &lt;code&gt;&amp;lt;-chan kubetypes.PodUpdate&lt;/code&gt; 以及相关的代码。故名思义，PodUpdate 定义了 pod 的相关更新，具体结构如下&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; PodUpdate &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Pods   []*v1.Pod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Op     PodOperation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Source &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="https://liubog2008.github.io/categories/kubernetes/"/>
    
      <category term="code" scheme="https://liubog2008.github.io/categories/kubernetes/code/"/>
    
    
      <category term="kubernetes" scheme="https://liubog2008.github.io/tags/kubernetes/"/>
    
      <category term="kubelet" scheme="https://liubog2008.github.io/tags/kubelet/"/>
    
  </entry>
  
  <entry>
    <title>rolling update 时出错原因分析</title>
    <link href="https://liubog2008.github.io/2020/04/12/ipvs-conn-reuse-mode/"/>
    <id>https://liubog2008.github.io/2020/04/12/ipvs-conn-reuse-mode/</id>
    <published>2020-04-12T11:07:21.000Z</published>
    <updated>2020-04-12T11:12:23.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>之前发现 coredns rolling update 的时候会出现丢包的情况，一步步顺藤摸瓜最后将问题定位到了 ipvs 的实现上，然后发现 ipvs 其实有不少令人窒息的操作，记录一下以作纪念。</p><h3 id="从-rolling-update-说起"><a href="#从-rolling-update-说起" class="headerlink" title="从 rolling update 说起"></a>从 rolling update 说起</h3><p>rolling update 作为 k8s 早期的核心功能，可以说是大杀器一般的存在，极大的保障了升级上线时的服务质量。然而这次丢包让我深入到 rolling update 的核心链路，才发现事情远不是如此简单。</p><p>rolling update 简单来说就是对多个副本的服务来说，一台一台的重启副本来达到更新的目的，以此来做到最小化甚至消除更新对服务的影响。</p><p>而为了做到 rolling update 对服务无影响，需要服务提供 graceful shutdown 的功能，并和 k8s 的机制相配合。</p><p>什么是 graceful shutdown 呢？简单来说就是服务端在收到关闭的信号后，不立刻关闭程序，而是不再接收请求，并等待现有的所有连接关闭后再关闭程序。</p><p>以上两个功能相配合，就能做到满足一定条件的客户端不再感知到后端服务的更新。</p><a id="more"></a><h3 id="coredns-丢包"><a href="#coredns-丢包" class="headerlink" title="coredns 丢包"></a>coredns 丢包</h3><p>当然了，理想总是美好的，但现实是配置了以上两个功能的 coredns 更新的时候丢包了。</p><p>整个问题查找的路径大概如下</p><ol><li>发现 coredns 更新时丢包了</li><li>发现 coredns 的某个副本已经关闭后依旧有包发向该副本</li><li>怀疑是 kube-proxy sync 规则到 ipvs 太慢的原因，验证后发现不是</li><li>开始怀疑是 ipvs 的原因，进一步发现 ipvs 会 cache 连接</li><li>确定了问题出现在 ipvs 连接复用上</li></ol><h3 id="ipvs-连接复用"><a href="#ipvs-连接复用" class="headerlink" title="ipvs 连接复用"></a>ipvs 连接复用</h3><p>简单来说，ipvs(NAT) 会 cache 连接，并且依据 ip 包的 source 来复用到 server 的连接，这个功能主要是用于提高 ipvs 的性能</p><p>然而在 rolling update 的时候，ipvs 将即将关闭的 server 的 weight 置为 0 后问题出现了 —— <code>新的连接 hit cache，继续被调度到了这个即将关闭的 server，然后刷新了cache 的过期时间</code></p><h3 id="conn-reuse-mode"><a href="#conn-reuse-mode" class="headerlink" title="conn_reuse_mode"></a>conn_reuse_mode</h3><p>问题出在 ipvs 的内核参数 <code>conn_reuse_mode</code> 上，以下是内核关于该参数的文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">conn_reuse_mode - INTEGER</span><br><span class="line">1 - default</span><br><span class="line"></span><br><span class="line">Controls how ipvs will deal with connections that are detected</span><br><span class="line">port reuse. It is a bitmap, with the values being:</span><br><span class="line"></span><br><span class="line">0: disable any special handling on port reuse. The new</span><br><span class="line">connection will be delivered to the same real server that was</span><br><span class="line">servicing the previous connection. This will effectively</span><br><span class="line">disable expire_nodest_conn.</span><br><span class="line"></span><br><span class="line">bit 1: enable rescheduling of new connections when it is safe.</span><br><span class="line">That is, whenever expire_nodest_conn and for TCP sockets, when</span><br><span class="line">the connection is in TIME_WAIT state (which is only possible if</span><br><span class="line">you use NAT mode).</span><br><span class="line"></span><br><span class="line">bit 2: it is bit 1 plus, for TCP connections, when connections</span><br><span class="line">are in FIN_WAIT state, as this is the last state seen by load</span><br><span class="line">balancer in Direct Routing mode. This bit helps on adding new</span><br><span class="line">real servers to a very busy cluster.</span><br></pre></td></tr></table></figure><p>可以发现，在 <code>conn_reuse_mode</code> 为 0 的时候，新连接总是会根据 cache 调度到之前的 real server 上</p><p>而在 <code>conn_reuse_mode</code> 为 1 的时候，在 real server 的 weight 为 0 或者 real server 被删除的时候新的链接会被重新调度</p><p>那么为什么 kube-proxy 要把默认值改为 0 呢？见 <a href="https://github.com/kubernetes/kubernetes/issues/70747" target="_blank" rel="noopener">issue 70747</a> 可以知道是因为改为 0 后性能上 可以提高不少</p><p>然而这一改却带来了这个问题</p><h3 id="drop-SYN-？"><a href="#drop-SYN-？" class="headerlink" title="drop SYN ？"></a>drop SYN ？</h3><p>那么改回来问题就解决了么？事实上没有，因为 <code>conn_reuse_mode</code> 为 1 时同样会遇到一个奇怪的问题</p><p>ipvs expire 连接调用了 <code>ip_vs_conn_expire_now</code> 的函数，这个函数是将 expire 连接的计时器设置为 0 来触发 expire 的函数</p><p>然而新连接的建立会刷新 nf_conntrack 信息，然后 expire 函数的触发会误删 nf_contrack 的信息，整个流程大概如下</p><ol><li>TCP 连接被关闭</li><li>新连接开始建立，conntrack 被替代</li><li>ipvs 重新调度新连接</li><li>ipvs conn expire 时间置 0</li><li>ipvs expire 被调用</li><li>conntrack 被清理 (清理的是新连接的 conntrack)</li></ol><p>而这个 bug 的修复方法非常的简单粗暴，就是将新连接的 SYN 包丢弃，然后依赖 TCP 重发机制来保证正确性</p><p>这样做的结果很简单，某些请求的 rt 至少要延长到 1s (重发 SYN 的间隔)</p><p>以下是修复该问题的 commit message</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">commit f719e3754ee2f7275437e61a6afd520181fdd43b</span><br><span class="line">Author: Julian Anastasov &lt;ja@ssi.bg&gt;</span><br><span class="line">Date:   Sat Mar 5 15:03:22 2016 +0200</span><br><span class="line"></span><br><span class="line">    ipvs: drop first packet to redirect conntrack</span><br><span class="line"></span><br><span class="line">    Jiri Bohac is reporting for a problem where the attempt</span><br><span class="line">    to reschedule existing connection to another real server</span><br><span class="line">    needs proper redirect for the conntrack used by the IPVS</span><br><span class="line">    connection. For example, when IPVS connection is created</span><br><span class="line">    to NAT-ed real server we alter the reply direction of</span><br><span class="line">    conntrack. If we later decide to select different real</span><br><span class="line">    server we can not alter again the conntrack. And if we</span><br><span class="line">    expire the old connection, the new connection is left</span><br><span class="line">    without conntrack.</span><br><span class="line"></span><br><span class="line">    So, the only way to redirect both the IPVS connection and</span><br><span class="line">    the Netfilter&apos;s conntrack is to drop the SYN packet that</span><br><span class="line">    hits existing connection, to wait for the next jiffie</span><br><span class="line">    to expire the old connection and its conntrack and to rely</span><br><span class="line">    on client&apos;s retransmission to create new connection as</span><br><span class="line">    usually.</span><br><span class="line"></span><br><span class="line">    Jiri Bohac provided a fix that drops all SYNs on rescheduling,</span><br><span class="line">    I extended his patch to do such drops only for connections</span><br><span class="line">    that use conntrack. Here is the original report from Jiri Bohac:</span><br><span class="line"></span><br><span class="line">    Since commit dc7b3eb900aa (&quot;ipvs: Fix reuse connection if real server</span><br><span class="line">    is dead&quot;), new connections to dead servers are redistributed</span><br><span class="line">    immediately to new servers.  The old connection is expired using</span><br><span class="line">    ip_vs_conn_expire_now() which sets the connection timer to expire</span><br><span class="line">    immediately.</span><br><span class="line"></span><br><span class="line">    However, before the timer callback, ip_vs_conn_expire(), is run</span><br><span class="line">    to clean the connection&apos;s conntrack entry, the new redistributed</span><br><span class="line">    connection may already be established and its conntrack removed</span><br><span class="line">    instead.</span><br><span class="line"></span><br><span class="line">    Fix this by dropping the first packet of the new connection</span><br><span class="line">    instead, like we do when the destination server is not available.</span><br><span class="line">    The timer will have deleted the old conntrack entry long before</span><br><span class="line">    the first packet of the new connection is retransmitted.</span><br><span class="line"></span><br><span class="line">    Fixes: dc7b3eb900aa (&quot;ipvs: Fix reuse connection if real server is dead&quot;)</span><br><span class="line">    Signed-off-by: Jiri Bohac &lt;jbohac@suse.cz&gt;</span><br><span class="line">    Signed-off-by: Julian Anastasov &lt;ja@ssi.bg&gt;</span><br><span class="line">    Signed-off-by: Simon Horman &lt;horms@verge.net.au&gt;</span><br></pre></td></tr></table></figure><p>见 <a href="https://github.com/kubernetes/kubernetes/issues/81775" target="_blank" rel="noopener">issue 81775</a> 关于该问题的讨论</p><h3 id="等等问题不是出在-UDP-么"><a href="#等等问题不是出在-UDP-么" class="headerlink" title="等等问题不是出在 UDP 么"></a>等等问题不是出在 UDP 么</h3><p>眼尖的人已经发现了，问题最初来自于 DNS 请求，而 DNS 请求往往是 UDP 协议。然而上面一堆都是 TCP 连接的问题(TCP 的问题关我 UDP 什么事情)。</p><p>于是去源代码找答案，以下是关键代码一，也就是 <code>conn_reuse_mode</code> 生效的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">conn_reuse_mode = sysctl_conn_reuse_mode(ipvs);</span><br><span class="line">if (conn_reuse_mode &amp;&amp; !iph.fragoffs &amp;&amp; is_new_conn(skb, &amp;iph) &amp;&amp; cp) &#123;</span><br><span class="line">bool uses_ct = false, resched = false;</span><br><span class="line"></span><br><span class="line">if (unlikely(sysctl_expire_nodest_conn(ipvs)) &amp;&amp; cp-&gt;dest &amp;&amp;</span><br><span class="line">    unlikely(!atomic_read(&amp;cp-&gt;dest-&gt;weight))) &#123;</span><br><span class="line">resched = true;</span><br><span class="line">uses_ct = ip_vs_conn_uses_conntrack(cp, skb);</span><br><span class="line">&#125; else if (is_new_conn_expected(cp, conn_reuse_mode)) &#123;</span><br><span class="line">uses_ct = ip_vs_conn_uses_conntrack(cp, skb);</span><br><span class="line">if (!atomic_read(&amp;cp-&gt;n_control)) &#123;</span><br><span class="line">resched = true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">/* Do not reschedule controlling connection</span><br><span class="line"> * that uses conntrack while it is still</span><br><span class="line"> * referenced by controlled connection(s).</span><br><span class="line"> */</span><br><span class="line">resched = !uses_ct;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (resched) &#123;</span><br><span class="line">if (!atomic_read(&amp;cp-&gt;n_control))</span><br><span class="line">ip_vs_conn_expire_now(cp);</span><br><span class="line">__ip_vs_conn_put(cp);</span><br><span class="line">if (uses_ct)</span><br><span class="line">return NF_DROP;</span><br><span class="line">cp = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 reschedule 至少需要满足以下条件</p><ol><li>conn_reuse_mode 不为 0</li><li>is_new_conn(skb, &amp;iph) 需要为 true</li></ol><p>而 is_new_conn 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static inline bool is_new_conn(const struct sk_buff *skb,</span><br><span class="line">       struct ip_vs_iphdr *iph)</span><br><span class="line">&#123;</span><br><span class="line">switch (iph-&gt;protocol) &#123;</span><br><span class="line">case IPPROTO_TCP: &#123;</span><br><span class="line">struct tcphdr _tcph, *th;</span><br><span class="line"></span><br><span class="line">th = skb_header_pointer(skb, iph-&gt;len, sizeof(_tcph), &amp;_tcph);</span><br><span class="line">if (th == NULL)</span><br><span class="line">return false;</span><br><span class="line">return th-&gt;syn;</span><br><span class="line">&#125;</span><br><span class="line">case IPPROTO_SCTP: &#123;</span><br><span class="line">struct sctp_chunkhdr *sch, schunk;</span><br><span class="line"></span><br><span class="line">sch = skb_header_pointer(skb, iph-&gt;len + sizeof(struct sctphdr),</span><br><span class="line"> sizeof(schunk), &amp;schunk);</span><br><span class="line">if (sch == NULL)</span><br><span class="line">return false;</span><br><span class="line">return sch-&gt;type == SCTP_CID_INIT;</span><br><span class="line">&#125;</span><br><span class="line">default:</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然该函数只处理了 TCP 和 STCP 两种协议，其他协议都默认返回 false，因此 <code>conn_reuse_mode</code> 对 UDP 并没有任何用处。</p><p>然后看到了第二段关键代码如下，即在 real server 真正被删除后的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (cp-&gt;dest &amp;&amp; !(cp-&gt;dest-&gt;flags &amp; IP_VS_DEST_F_AVAILABLE)) &#123;</span><br><span class="line">/* the destination server is not available */</span><br><span class="line"></span><br><span class="line">__u32 flags = cp-&gt;flags;</span><br><span class="line"></span><br><span class="line">/* when timer already started, silently drop the packet.*/</span><br><span class="line">if (timer_pending(&amp;cp-&gt;timer))</span><br><span class="line">__ip_vs_conn_put(cp);</span><br><span class="line">else</span><br><span class="line">ip_vs_conn_put(cp);</span><br><span class="line"></span><br><span class="line">if (sysctl_expire_nodest_conn(ipvs) &amp;&amp;</span><br><span class="line">    !(flags &amp; IP_VS_CONN_F_ONE_PACKET)) &#123;</span><br><span class="line">/* try to expire the connection immediately */</span><br><span class="line">ip_vs_conn_expire_now(cp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return NF_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，UDP 包并不会在 real server 的 weight 为 0 时重新调度，如果 client 端请求量巨大，可能会不断 hit cache 直到 real server 被移除，然后导致大量请求被 Drop</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说 ipvs 里还有不少问题，而这些问题会导致 rolling update 时总有几个连接超时或出错</p><p>对于 TCP 连接而言，<code>conn_reuse_mode</code> 为 0 时部分连接可能会丢失，而为 1 时部分连接可能会出现 SYN 包重发导致的超时</p><p>而对于 UDP 连接而言，当请求量巨大时，几乎可以说 rolling update 总是会丢包了，尤其是对 DNS 而言</p><p>感受最深的是内核中竟然会用 Drop SYN 包这种骚操作来 fix 问题。。。服务的无感知更新真是太艰难了</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;p&gt;之前发现 coredns rolling update 的时候会出现丢包的情况，一步步顺藤摸瓜最后将问题定位到了 ipvs 的实现上，然后发现 ipvs 其实有不少令人窒息的操作，记录一下以作纪念。&lt;/p&gt;&lt;h3 id=&quot;从-rolling-update-说起&quot;&gt;&lt;a href=&quot;#从-rolling-update-说起&quot; class=&quot;headerlink&quot; title=&quot;从 rolling update 说起&quot;&gt;&lt;/a&gt;从 rolling update 说起&lt;/h3&gt;&lt;p&gt;rolling update 作为 k8s 早期的核心功能，可以说是大杀器一般的存在，极大的保障了升级上线时的服务质量。然而这次丢包让我深入到 rolling update 的核心链路，才发现事情远不是如此简单。&lt;/p&gt;&lt;p&gt;rolling update 简单来说就是对多个副本的服务来说，一台一台的重启副本来达到更新的目的，以此来做到最小化甚至消除更新对服务的影响。&lt;/p&gt;&lt;p&gt;而为了做到 rolling update 对服务无影响，需要服务提供 graceful shutdown 的功能，并和 k8s 的机制相配合。&lt;/p&gt;&lt;p&gt;什么是 graceful shutdown 呢？简单来说就是服务端在收到关闭的信号后，不立刻关闭程序，而是不再接收请求，并等待现有的所有连接关闭后再关闭程序。&lt;/p&gt;&lt;p&gt;以上两个功能相配合，就能做到满足一定条件的客户端不再感知到后端服务的更新。&lt;/p&gt;
    
    </summary>
    
      <category term="kernel" scheme="https://liubog2008.github.io/categories/kernel/"/>
    
      <category term="ipvs" scheme="https://liubog2008.github.io/categories/kernel/ipvs/"/>
    
    
      <category term="kernel" scheme="https://liubog2008.github.io/tags/kernel/"/>
    
      <category term="ipvs" scheme="https://liubog2008.github.io/tags/ipvs/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 源码分析之 kubelet(一)</title>
    <link href="https://liubog2008.github.io/2019/04/08/kubernetes/kubelet-1/"/>
    <id>https://liubog2008.github.io/2019/04/08/kubernetes/kubelet-1/</id>
    <published>2019-04-08T13:15:22.000Z</published>
    <updated>2019-04-09T06:25:20.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><p>v1.12.4</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>面试被问 pod 的生命周期，说到 kubelet 创建 pod 的部分时只提了 kubelet 发 API 给 docker 创建 container，被认为对 kubernetes 不够熟悉。<br>想了想接触 kubernetes 这么多年了，确实没有真的系统的看过所有代码，认了，查漏补缺吧，挨个写写 kubernetes 的这些个核心组件。<br>之所以用 1.12.4 是因为本地恰好用的 1.12.4，如果 1.14 有想关注的更新会额外写 blog。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>kubelet 是什么就不说了，它的主要代码集中在 kubernetes 项目下的 <code>/pkg/kubelet</code> 位置，总的来说项目结构是相当的清晰。下面是一级目录的简单说明。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- apis/              kubelet 的 api 相关</span><br><span class="line">- cadvisor/          容器指标采集系统，https://github.com/google/cadvisor</span><br><span class="line">- certificate/       证书相关</span><br><span class="line">- checkpoint/        checkpoint 功能 (没看前真不知道这功能)</span><br><span class="line">- checkpointmanager/ checkpoint 管理</span><br><span class="line">- client/            用来访问 kubelet 的 client?</span><br><span class="line">- cloudresource/     用来和云服务交互的部分</span><br><span class="line">- cm/                cgroups manager (cgroups or container?)</span><br><span class="line">- config/            pod config 相关？</span><br><span class="line">- configmap/         configmap 相关</span><br><span class="line">- container/         CRI 相关</span><br><span class="line">- custommetrics/     同文件名</span><br><span class="line">- dockershim/        docker interface</span><br><span class="line">- envvars/           容器里的一些环境变量</span><br><span class="line">- events/            一堆事件的 constant</span><br><span class="line">- eviction/          pod eviction，这个亲切</span><br><span class="line">- images/            容器镜像相关，主要是 pull 和 gc</span><br><span class="line">- kubeletconfig/     kubelet config (凭什么不是上面那个 config 改名)</span><br><span class="line">- kuberuntime/       kubelet runtime 相关</span><br><span class="line">- leaky/             emmm... 就是一些要弄死的代码，而且看起来已经都弄死了</span><br><span class="line">- lifecycle/         pod lifecycle 相关的接口</span><br><span class="line">- logs/              container log 相关，主要是 rotation 之类的逻辑</span><br><span class="line">- metrics/           prometheus metrics</span><br><span class="line">- mountpod/          volume plugin 相关？</span><br><span class="line">- network/           用来配置 pod dns 的</span><br><span class="line">- nodelease/         又是一个不清楚的功能，看起来和租户相关？</span><br><span class="line">- nodestatus/        定义了很多节点状态更新用的 setter</span><br><span class="line">- pleg/              pod lifecycle event generator</span><br><span class="line">- pod/               pod manager</span><br><span class="line">- preemption/        优先级抢占相关</span><br><span class="line">- prober/            pod liveness or readiness probe</span><br><span class="line">- qos/               算 oom 分的</span><br><span class="line">- remote/            貌似实现了 cri 定义的一些 service?</span><br><span class="line">- secret/            挂载 secret 相关</span><br><span class="line">- server/            kubelet 提供的 exec，portforward 等 API的 server</span><br><span class="line">- stats/             CRI stats provider</span><br><span class="line">- status/            pod status manager</span><br><span class="line">- sysctl/            sysctl 相关 (并不知道干什么用)</span><br><span class="line">- token/             service account token 相关</span><br><span class="line">- types/             emmm... 一些 types？</span><br><span class="line">- util/              一些 utils</span><br><span class="line">- volumemanager/     数据卷管理</span><br><span class="line">- winstats/          windows 节点相关</span><br></pre></td></tr></table></figure><p>内容还是很多的，浏览思路是以 pod 的整个生命周期为线索，抓住主线代码，为此罗列以下几个关键问题：</p><ul><li>如何创建 pod</li><li>如何 sync pod 状态</li><li>如何调用 API 创建 container</li><li>pod 的 configmap 和 secret 如何管理</li><li>pod 的 volume 如何管理</li><li>pod 的 network 如何管理</li><li>如何删除 pod</li></ul><p>除此之外按照 feature 的视角来看还有：</p><ul><li>metrics 采集</li><li>remote command 相关的实现</li><li>eviction 功能的实现</li><li>CRI 相关的实现</li><li>其他</li></ul><h2 id="Pod-Lifecycle"><a href="#Pod-Lifecycle" class="headerlink" title="Pod Lifecycle"></a>Pod Lifecycle</h2><p>pod 的整个生命周期往往要从它被 controller 创建开始聊起。然而本文的主要关注点在 kubelet 相关的代码上，因此更关心 pod 被调度到某个节点，也就是当 pod 的 nodeName 字段不为空后会发生什么。</p><h3 id="从-kubelet-go-开始聊起"><a href="#从-kubelet-go-开始聊起" class="headerlink" title="从 kubelet.go 开始聊起"></a>从 kubelet.go 开始聊起</h3><p>从什么地方找出 pod 相关的代码呢？我们可以看到 <code>/pkg/kubelet</code> 文件夹下有一个叫做 <code>kubelet.go</code> 的文件，显然这是 kubelet 主体代码的入口。</p><p>很快我们发现里面有一个叫做 <code>Kubelet</code> 的结构体和一个叫做 <code>NewMainKubelet</code> 以及一个 <code>(kl *Kubelet) Run(updates &lt;-chan kubetypes.PodUpdate)</code> 的函数。</p><p>其中 <code>Kubelet</code> 是 kubelet 的核心结构体，而 <code>NewMainKubelet</code> 是构造函数，<code>Run</code> 则是入口函数。</p><p>看看 <code>Run</code> 这个函数做了什么：</p><ul><li>初始化了 <code>kl.logServer</code></li><li>检查了 <code>kl.kubeClient</code>，之所以这里可能为空是因为 apiserver 可以是 kubelet 拉起来的</li><li>运行 <code>kl.cloudResourceManager</code></li><li>运行 <code>kl.initializeModules</code><ul><li>注册 prometheus metrics</li><li>初始化 kubelet 所需的文件夹</li><li>初始化 container 日志文件夹</li><li>运行管理镜像 GC 的模块 <code>kl.imageManager</code></li><li>运行证书管理模块 <code>kl.serverCertificateManager</code></li><li>运行 OOM 监控模块 <code>kl.oomWatcher</code></li><li>运行资源分析模块 <code>kl.resourceAnalyzer</code></li></ul></li><li>运行 volume 管理组件 <code>kl.volumeManager</code></li><li>如果 apiserver 已经运行了<ul><li>运行 goroutine 定时同步 node 状态</li><li>快速进行一次状态同步</li><li>运行 <code>kl.nodeLeaseController</code></li></ul></li><li>运行 goroutine 同步 container runtime uptime</li><li>运行 goroutine 同步 iptables 规则 (暂未明白这个同步的意义)</li><li>运行 <code>kl.podKiller</code></li><li>运行 pod 状态管理模块 <code>kl.statusManager</code></li><li>运行 pod 探针模块 <code>kl.probeManager</code></li><li>运行 pleg (pod lifecycle event generator) 模块 <code>kl.pleg</code></li><li>运行主循环 <code>kl.syncLoop</code></li></ul><p><code>kl.syncLoop</code> 接受两个参数，第一个是 <code>&lt;-chan kubetypes.PodUpdate</code>，第二个是 <code>SyncHandler</code>，<code>SyncHandler</code> 定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyncHandler is an interface implemented by Kubelet, for testability</span></span><br><span class="line"><span class="keyword">type</span> SyncHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">HandlePodAdditions(pods []*v1.Pod)</span><br><span class="line">HandlePodUpdates(pods []*v1.Pod)</span><br><span class="line">HandlePodRemoves(pods []*v1.Pod)</span><br><span class="line">HandlePodReconcile(pods []*v1.Pod)</span><br><span class="line">HandlePodSyncs(pods []*v1.Pod)</span><br><span class="line">HandlePodCleanups() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>kl.syncLoop</code> 中调用了 <code>kl.syncLoopIteration</code>，接收了以下几种 chan：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- configCh       &lt;-chan kubetypes.PodUpdate</span><br><span class="line">- syncCh         &lt;-chan time.Time，定时触发的 resync 操作</span><br><span class="line">- housekeepingCh &lt;-chan time.Time，定时触发的清理操作</span><br><span class="line">- plegCh         &lt;-chan *pleg.PodLifecycleEvent</span><br></pre></td></tr></table></figure><p>其中 <code>configCh</code> 会触发 <code>HandlePodAdditions</code>，<code>HandlePodUpdates</code>，<code>HandlePodRemoves</code>，<code>HandlePodReconcile</code> 四种操作。而 <code>syncCh</code> 和 <code>plegCh</code> 会触发 <code>HandlePodSyncs</code> 操作，<code>housekeepingCh</code> 会触发 <code>HandlePodCleanups</code> 操作。</p><p>到这个时候 pod 的生命周期处理的入口基本上找到了，看到这新的问题来了：</p><ul><li><code>&lt;-chan kubetypes.PodUpdate</code> 到底是怎么触发的，对应的四个操作都做了什么</li><li><code>HandlePodSyncs</code> 和上述四个操作什么关系（凭什么你叫 sync）</li><li><code>HandlePodCleanups</code> 和 <code>HandlePodRemoves</code> 的区别</li><li>为什么需要定时触发 <code>syncCh</code></li><li>为什么需要 <code>housekeeping</code></li><li><code>pleg</code> 模块到底做了什么</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Version&quot;&gt;&lt;a href=&quot;#Version&quot; class=&quot;headerlink&quot; title=&quot;Version&quot;&gt;&lt;/a&gt;Version&lt;/h2&gt;&lt;p&gt;v1.12.4&lt;/p&gt;&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;面试被问 pod 的生命周期，说到 kubelet 创建 pod 的部分时只提了 kubelet 发 API 给 docker 创建 container，被认为对 kubernetes 不够熟悉。&lt;br&gt;想了想接触 kubernetes 这么多年了，确实没有真的系统的看过所有代码，认了，查漏补缺吧，挨个写写 kubernetes 的这些个核心组件。&lt;br&gt;之所以用 1.12.4 是因为本地恰好用的 1.12.4，如果 1.14 有想关注的更新会额外写 blog。&lt;/p&gt;&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;kubelet 是什么就不说了，它的主要代码集中在 kubernetes 项目下的 &lt;code&gt;/pkg/kubelet&lt;/code&gt; 位置，总的来说项目结构是相当的清晰。下面是一级目录的简单说明。&lt;/p&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="https://liubog2008.github.io/categories/kubernetes/"/>
    
      <category term="code" scheme="https://liubog2008.github.io/categories/kubernetes/code/"/>
    
    
      <category term="kubernetes" scheme="https://liubog2008.github.io/tags/kubernetes/"/>
    
      <category term="kubelet" scheme="https://liubog2008.github.io/tags/kubelet/"/>
    
  </entry>
  
  <entry>
    <title>Rust 学习历程（二）</title>
    <link href="https://liubog2008.github.io/2019/02/25/learn-rust-two/"/>
    <id>https://liubog2008.github.io/2019/02/25/learn-rust-two/</id>
    <published>2019-02-25T13:46:43.000Z</published>
    <updated>2019-04-09T06:25:10.760Z</updated>
    
    <content type="html"><![CDATA[<p>提到 rust 不得不提的就是 rust 的 <code>ownership</code> 机制，坦白来讲如果不是 <code>ownership</code> 我一定不会对 rust 感兴趣。</p><h2 id="What’s-ownership"><a href="#What’s-ownership" class="headerlink" title="What’s ownership"></a>What’s ownership</h2><p>ownership 是 rust 用来解决内存回收问题的方案，现阶段关于堆内存的回收主要有三种方案：</p><ul><li>手动回收，高性能的中古时代的语言如 C/C++ 等都是如此。</li><li>垃圾回收，极大的降低了程序员心智负担，同时在一定程度上提高了程序的资源消耗。</li><li>rust 的 ownership 方案，通过规定 ownership 来确保离开作用域时自动回收内存。</li></ul><p>总的来说 <code>ownership</code> 就是 rust 用来解决内存回收问题的方案 —— 像栈变量一样离开作用域就被回收，并因此规定所有的堆变量只有一个 <code>owner</code>。</p><a id="more"></a><h2 id="Why-only-one-owner"><a href="#Why-only-one-owner" class="headerlink" title="Why only one owner"></a>Why only one owner</h2><p>堆变量只有一个 <code>owner</code> 是什么意思呢？简单来说就是无法给一个堆变量两个名字。如下面的代码：<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// failed because of s1 has been moved</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, world!"</span>, s1);</span><br></pre></td></tr></table></figure><p></p><p>这段代码非常好的体现了 <code>ownership</code> 的概念，<code>s1</code> 和 <code>s2</code> 不能同时作为 String 中 <code>hello</code> 的 <code>owner</code>。在将 <code>s1</code> 赋值给 <code>s2</code> 时 <code>hello</code> 的 <code>owner</code> 发生了变化。</p><p>那么为什么要做出这种不太方便的规定呢？本质上是为了避免多个 <code>owner</code> 带来的二次回收问题。如果 <code>s1</code> 和 <code>s2</code> 都拥有 <code>hello</code> 的 reference 的话，在回收 <code>s1</code> 和 <code>s2</code> 时 <code>hello</code> 会被回收两次。</p><h2 id="Mutable"><a href="#Mutable" class="headerlink" title="Mutable"></a>Mutable</h2><p>rust 规定了变量默认是 immutable 的，类似 <code>const</code> 关键字。然后用 <code>mut</code> 变量定义了可以被修改的变量。</p><p>见识少的我第一次发现有语言是这么设计的，但是很快我发现这种设定的一个小优点，它解决了用指针传递变量时不清楚函数是否会修改入参的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := A&#123;&#125;</span><br><span class="line"><span class="comment">// Is x changed?</span></span><br><span class="line">thirdParty(&amp;x)</span><br></pre></td></tr></table></figure><p>当然 c++ 通过 <code>const</code> 来定义有同样的效果，不过根据程序猿惯性定律——是否使用某特性都不影响程序运行时总是倾向不使用。<code>mut</code> 很好的降低了心智负担——不需要考虑哪些参数要加 <code>mut</code>，因为不加跑不起来，不像 <code>const</code> 加不加都能跑。另外个人认为默认 immutable 比默认 mutable 能更好的避免很多的错误。</p><p>当然， golang 表示这不重要，C 对此表示赞同。</p><p>以下是一些函数定义，可以很明显的发现只有第三种加了 <code>mut</code> 关键字的函数我们才需要关心数据是否发生改变。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(s: <span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// also error</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">changeWithRef</span></span>(s: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">changeWithMutRef</span></span>(s: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Is-it-out-of-scope"><a href="#Is-it-out-of-scope" class="headerlink" title="Is it out of scope?"></a>Is it out of scope?</h2><p>rust 的 <code>ownership</code> 机制带来了很多有趣的问题，写 rust 时经常需要判断某个变量是否 <code>out of scope</code></p><p>现在我们定义了一个 String, 然后将这个 String 传入一个函数，什么情况下这个 String 能够离开这个函数而不被回收呢？</p><p>存在以下四种情况：</p><ul><li><code>fn a(s: String)</code>: 回收，不可改</li><li><code>fn b(s: &amp;String)</code>: 不回收，不可改</li><li><code>fn c(s: mut String)</code>: 回收，可以改，改不改都一样</li><li><code>fn d(s: &amp;mut String)</code>: 不回收，可以改</li></ul><p>这里引入了一个 <code>borrow</code> 和 <code>reference</code> (<code>&amp;String</code>) 的概念。<code>reference</code> 指向某个变量但是不会修改它的 <code>ownership</code>。这种行为被称为 <code>borrow</code> 借用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// borrow s</span></span><br><span class="line"><span class="keyword">let</span> refer = &amp;s;</span><br><span class="line">try_change_owner(refer);</span><br><span class="line"><span class="comment">// it's ok to print refer</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, refer);</span><br></pre></td></tr></table></figure><h2 id="By-the-way"><a href="#By-the-way" class="headerlink" title="By the way"></a>By the way</h2><ul><li>rust 的 ownership 可以说是非常有趣，但是它也极大的提高了写代码的心智负担，特别是在还不熟悉的时候。</li><li>有一些特殊情况下某些变量可能需要多个 owner (比如 graph 之类的数据结构)，此时可以通过 rust 的 <code>Rc&lt;T&gt;</code> 来解决。</li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>感觉写 rust 前要先画个图了，一个不小心 ownership 就被挪走了，特别是实现一些指来指去的的数据结构时。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到 rust 不得不提的就是 rust 的 &lt;code&gt;ownership&lt;/code&gt; 机制，坦白来讲如果不是 &lt;code&gt;ownership&lt;/code&gt; 我一定不会对 rust 感兴趣。&lt;/p&gt;&lt;h2 id=&quot;What’s-ownership&quot;&gt;&lt;a href=&quot;#What’s-ownership&quot; class=&quot;headerlink&quot; title=&quot;What’s ownership&quot;&gt;&lt;/a&gt;What’s ownership&lt;/h2&gt;&lt;p&gt;ownership 是 rust 用来解决内存回收问题的方案，现阶段关于堆内存的回收主要有三种方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;手动回收，高性能的中古时代的语言如 C/C++ 等都是如此。&lt;/li&gt;&lt;li&gt;垃圾回收，极大的降低了程序员心智负担，同时在一定程度上提高了程序的资源消耗。&lt;/li&gt;&lt;li&gt;rust 的 ownership 方案，通过规定 ownership 来确保离开作用域时自动回收内存。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总的来说 &lt;code&gt;ownership&lt;/code&gt; 就是 rust 用来解决内存回收问题的方案 —— 像栈变量一样离开作用域就被回收，并因此规定所有的堆变量只有一个 &lt;code&gt;owner&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://liubog2008.github.io/categories/language/"/>
    
      <category term="rust" scheme="https://liubog2008.github.io/categories/language/rust/"/>
    
    
      <category term="rust" scheme="https://liubog2008.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RBAC 以及权限设计 (一)</title>
    <link href="https://liubog2008.github.io/2019/02/20/rbac-one/"/>
    <id>https://liubog2008.github.io/2019/02/20/rbac-one/</id>
    <published>2019-02-20T15:35:51.000Z</published>
    <updated>2020-04-12T11:10:08.878Z</updated>
    
    <content type="html"><![CDATA[<p>权限设计真的是一个大坑，对整个权限模型的理解和 <code>Best Practise</code> 的思考花费了我相当多的时间，因此想要对其做一个记录和总结。本文主要针对系统设计时如何处理权限设计做一个理论上的思考以及实践上的反思，并希望能够针对权限设计探讨一定场景下的 <code>Best Practise</code></p><a id="more"></a><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="AuthZ"><a href="#AuthZ" class="headerlink" title="AuthZ"></a>AuthZ</h3><p>我们在提到权限设计的时候通常是指 <code>Authorization</code> 阶段，这个阶段在用户认证之后，接下来我们需要判断用户能够访问什么资源。不同于 <code>AuthN</code> 有很多的标准方案，<code>AuthZ</code> 几乎只有几个寥寥的理论模型，并且几乎都会对业务设计带来影响。</p><h3 id="Subject-amp-Permission"><a href="#Subject-amp-Permission" class="headerlink" title="Subject &amp; Permission"></a>Subject &amp; Permission</h3><p>权限主体 (subject) 往往是指权限的拥有对象。它可以代表一个用户，一个群组，甚至一个更大的组织架构。</p><p>权限 (permission) 是一个抽象概念，它可以是能否访问某个 API，也可以是能否展示某个 UI 组件。通常意义上来说权限可以分为数据权限和功能权限 (我只在某个中文 blog 里看到过这种分法，不知道是否有理论支撑，不过个人感觉还是挺合理的)。</p><p>功能权限通常指能不能做某件事，比如能不能访问某个 API。而数据权限通常指能做到什么程度，比如访问金额 20000 以上的订单。二者的区别在于功能权限的边界相对确定 (比如能否访问订单一般不会变为能否访问购物车)，而数据权限常常是模糊的，不可数的，不可预料的 (比如 20000 以上的订单可能会变化，反复分割，甚至自定义)</p><p>这里引入一个资源的概念，权限可以抽象为<code>对资源的访问能力</code>。那么功能权限可以认为对资源是无感知的，权限系统不关心资源是什么，长什么样。而数据权限对资源有感知，它往往需要知道资源的某些特征，并针对性的设计。</p><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>RBAC 是一种权限设计的理论模型，有以下四种子模型，功能依次增强。<a href="http://www.woshipm.com/pd/440765.html" target="_blank" rel="noopener">这是一篇 RBAC 模型的介绍</a> (是我看到的关于 RBAC 的中文文章中最好的几篇之一)。</p><ul><li>RBAC0</li><li>RBAC1</li><li>RBAC2</li><li>RBAC3</li></ul><p>TODO: 详细讨论一下 RBAC 的四种子模型的区别。</p><p>RBAC 的理论核心就是将权限 (permission) 和权限主体 (subject) 之间添加一层角色 (role) 来实现权限分配和设计的解耦。</p><blockquote><p>All problems in computer science can be solved by another level of indirection.<br>– David Wheeler</p></blockquote><p>RBAC 成功的解决了 <code>subject</code> 和 <code>permission</code> 直接关联时权限粒度过细带来的分配困难 (每建立一个 subject 都需要绑定非常多个 permission) 以及权限修改带来的再分配困难 (每增加一个 permission 都可能需要修改 subject 和新 permission 的绑定)。</p><h2 id="RBAC-实践问题总结"><a href="#RBAC-实践问题总结" class="headerlink" title="RBAC 实践问题总结"></a>RBAC 实践问题总结</h2><p>在 RBAC 的实践过程中我们遇到了如下问题：</p><ul><li>通用化 or 业务化</li><li>如何定义 permission<ul><li>如何处理 UI 组件访问权限</li><li>如何处理 API 访问权限</li></ul></li><li>如何处理数据权限</li><li>权限分配功能的权限设计</li><li>多个角色间的权限聚合问题</li></ul><p>TODO: 挨个总结</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;权限设计真的是一个大坑，对整个权限模型的理解和 &lt;code&gt;Best Practise&lt;/code&gt; 的思考花费了我相当多的时间，因此想要对其做一个记录和总结。本文主要针对系统设计时如何处理权限设计做一个理论上的思考以及实践上的反思，并希望能够针对权限设计探讨一定场景下的 &lt;code&gt;Best Practise&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="arch" scheme="https://liubog2008.github.io/categories/arch/"/>
    
      <category term="rbac" scheme="https://liubog2008.github.io/categories/arch/rbac/"/>
    
    
      <category term="design" scheme="https://liubog2008.github.io/tags/design/"/>
    
      <category term="best practise" scheme="https://liubog2008.github.io/tags/best-practise/"/>
    
      <category term="rbac" scheme="https://liubog2008.github.io/tags/rbac/"/>
    
      <category term="authz" scheme="https://liubog2008.github.io/tags/authz/"/>
    
  </entry>
  
  <entry>
    <title>Rust 学习历程（一）</title>
    <link href="https://liubog2008.github.io/2019/02/18/learn-rust-one/"/>
    <id>https://liubog2008.github.io/2019/02/18/learn-rust-one/</id>
    <published>2019-02-18T12:43:07.000Z</published>
    <updated>2019-04-09T06:24:55.130Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要学习 rust，记录一下 rust 的学习历程。预计最终目标是用 rust 完成一个简单的 os 内核。由于个人 golang 用的比较多，会尽可能将 rust 相关的功能和 golang 进行对比。</p><p>希望能通过 rust 接触更多的编程思想，golang 写的都不会用范型了。</p><p>NOTE: 整个学习历程可能会比较跳跃</p><a id="more"></a><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>安装 rust 一帆风顺，cargo 还是很好用的 (当然可能是短期内没有踩到坑)。rust 的包管理几乎完爆了 golang，想起过去折腾 golang 的包管理还是很心累。再一想到过段时间可能又要从 dep 换掉真的令人内心爆炸。</p><p>以下是 rust hello world!<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>关于这段程序，我遇到了三个问题：</p><ol><li><code>println</code> 为什么后面加了 <code>!</code></li><li>最后的分号是否可选</li><li><code>println</code> 文档在哪</li></ol><h2 id="Marco"><a href="#Marco" class="headerlink" title="Marco"></a>Marco</h2><h3 id="macro-rules"><a href="#macro-rules" class="headerlink" title="macro_rules!"></a>macro_rules!</h3><p><code>println!</code> 表示这个是一个 <code>macro</code>。这让我想起了被 C 的 <code>#define</code> 支配的日子。<code>macro</code> 本质就是代码替换，但是骚操作太多，很多语言完全放弃了 macro 这种特性（比如 golang）。</p><p>rust 中 <code>macro</code> 的语法如下，<code>( $( $x:expr ),* )</code> 涉及到了 <strong>模式匹配</strong> 的概念。</p><p>TODO: 模式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>macro</code> 展开后如下，其中 <code>$()*</code> 类似 regex，表示生成任意次，次数对应匹配 <code>( $( $x:expr ),* )</code> 多少次，匹配 <code>1, 2, 3</code> 就生成了 3 次。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">    temp_vec.push(<span class="number">1</span>);</span><br><span class="line">    temp_vec.push(<span class="number">2</span>);</span><br><span class="line">    temp_vec.push(<span class="number">3</span>);</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后小萌新突然发现 rust 说 <code>macro_ruls!</code> 有很多问题，会被废弃。<br>emmmm… 反正 golang 都甚至没有 <code>macro</code></p><h3 id="procedural-macro"><a href="#procedural-macro" class="headerlink" title="procedural macro"></a>procedural macro</h3><p>还有一种 macro 叫做 procedural macro，有以下三种情况</p><ul><li>Custom <code>#[derive]</code> macros</li><li>Attribute-like macros</li><li>Function-like macros</li></ul><p>和上面的 <code>macro_rule</code> 的区别在于不是单纯的代码段替换而是接受一段 rust 代码后输出一段 rust 代码（感觉是可以自定义 macro template 逻辑的意思）</p><p>TODO: procedural macro 详解</p><h2 id="Statement-Or-Expression"><a href="#Statement-Or-Expression" class="headerlink" title="Statement Or Expression"></a>Statement Or Expression</h2><p>rust 被称为 <strong>expression language</strong>，<code>statement</code> 和 <code>expression</code> 最主要的区别在于 <code>expression</code> 总是返回值。</p><p>在 rust 中 <code>statement</code> 有以下几种</p><ul><li>Item: 类似各种 <code>fn</code> 之类的声明</li><li>LetStatement: <code>let</code> 语句</li><li>ExpressionStatement: <strong>所有的 <code>expression</code> 加上 <code>;</code> 后就成了 <code>statment</code></strong></li><li>MacroInvocationSemi: <code>macro</code> 相关的调用语句</li></ul><h3 id="Why-println-without-can-be-compiled"><a href="#Why-println-without-can-be-compiled" class="headerlink" title="Why println! without ; can be compiled"></a>Why println! without ; can be compiled</h3><p><code>Hello World</code> 中 <code>println!</code> 语句的最后是可以不添加分号的，原因是 rust 默认返回最后一个 <code>expression</code> 的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// it's ok</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ok</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">"aaa"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it's also ok</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">alsoOk</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">"aaa"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"aaa"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it's error, because expression only can be the last of fn</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">err</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">"aaa"</span>)</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外 rust 中还有一个<strong>设定是 <code>statement</code> 会返回 <code>()</code></strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x is [1,2,3]</span></span><br><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">    <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y is ()</span></span><br><span class="line"><span class="keyword">let</span> y = &#123;</span><br><span class="line">    <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>个人感觉这个操作挺迷的。</p><h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p><a href="https://doc.rust-lang.org/std/macro.println.html" target="_blank" rel="noopener">println 文档</a></p><p>文档的直观感觉还是很不错的。</p><h2 id="At-Last"><a href="#At-Last" class="headerlink" title="At Last"></a>At Last</h2><p>TODOs:</p><ul><li>模式匹配</li><li>procedural macro 详解</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想要学习 rust，记录一下 rust 的学习历程。预计最终目标是用 rust 完成一个简单的 os 内核。由于个人 golang 用的比较多，会尽可能将 rust 相关的功能和 golang 进行对比。&lt;/p&gt;&lt;p&gt;希望能通过 rust 接触更多的编程思想，golang 写的都不会用范型了。&lt;/p&gt;&lt;p&gt;NOTE: 整个学习历程可能会比较跳跃&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://liubog2008.github.io/categories/language/"/>
    
      <category term="rust" scheme="https://liubog2008.github.io/categories/language/rust/"/>
    
    
      <category term="rust" scheme="https://liubog2008.github.io/tags/rust/"/>
    
  </entry>
  
</feed>
